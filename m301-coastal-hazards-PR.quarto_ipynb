{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Who is Exposed to Coastal Hazards in Puerto Rico?\"\n",
        "author: \n",
        "   - Deborah Balk \n",
        "   - Shemontee Chowdhury\n",
        "   - Camilla Green \n",
        "   - Kytt MacManus\n",
        "   - Juan F. Martinez\n",
        "   - Hieu Tran \n",
        "   - Eldar Imanbekov \n",
        "   \n",
        "format: \n",
        "    html\n",
        "bibliography: lecz-references.bib\n",
        "---\n",
        "\n",
        "  \n",
        "# Overview\n",
        "\n",
        "This lesson introduces students to coastal hazards analysis in Puerto Rico using demographic and spatial data. You will use the [Low Elevation Coastal Zones (LECZ)](https://sedac.ciesin.columbia.edu/data/set/lecz-low-elevation-coastal-zones) dataset from NASA SEDAC and census block group data from the [US Census Bureau](https://www.census.gov/data.html) via the [IPUMS](https://www.ipums.org/) National Historical Geographic Information System (NHGIS) portal to understand which populations live in low-lying areas vulnerable to flooding and sea level rise. \n",
        "\n",
        "\n",
        "# Learning Objectives\n",
        "\n",
        "Through this hands-on activity, you will:\n",
        "\n",
        "- Extract population and housing data for 2010 and 2020 using the IPUMS API.\n",
        "- Preprocess and clean data using Python.\n",
        "- Create statistical summaries and **population pyramids** by age and sex.\n",
        "- Visualize patterns of population groups and vacancy in Puerto Rico’s counties.\n",
        "- Perform a **spatial overlay** with LECZ boundaries to assess coastal exposure.\n",
        "- Use Python packages to explore spatial patterns interactively.\n",
        "- Generate Age pyrimids to compare population groups in and out of the LECZ. \n",
        "\n",
        "This lesson emphasizes both **data science skills** and **critical spatial reasoning** about demographic vulnerability and environmental risk.\n",
        "\n",
        "# Introduction\n",
        "\n",
        "Coastal zones are inherently hazardous because they are exposed to sea-level rise, storm surge, and recurrent flooding, and Puerto Rico’s concentration of people, housing, and infrastructure along the shoreline heightens that risk. These hazards impact not only the environment but also public health, economic stability, and the daily lives of residents, especially the elderly and other vulnerable groups. By connecting demographic data with exposure to LECZs, this study helps find out who is most at risk and why understanding coastal hazard vulnerability in Puerto Rico is important.\n",
        "\n",
        "\n",
        "## U.S. Census Geography\n",
        "\n",
        "You may wonder why studies of the “entire” US often restrict themselves to the Continental U.S. (CONUS)? The simplest answer: data or computational limitations. Some U.S. territories lack full census variable coverage. \n",
        "\n",
        "Several U.S. territories, including **Puerto Rico**, are frequently excluded from national analyses because of inconsistent or incomplete data coverage, as well as geospatial processing challenges. For example:\n",
        "\n",
        "-   The **American Community Survey (ACS)** is not conducted in U.S. territories.\n",
        "-   Housing detail is limited in Guam, Northern Mariana Islands, U.S. Virgin Islands, and American Samoa.\n",
        "-   Puerto Rico conducts its own Community Survey, separate from ACS.\n",
        "\n",
        "Satellite-derived elevation data, such as NASA's Shuttle Radar Topography Mission (SRTM), also suffer from variable accuracy near polar regions and small islands [See this U.S. Census Bureau note for more.](https://docs.google.com/document/d/1bKYopZoMLCD2djl2vc3pwNSKwGDk6TKRI79swefIvKY/edit?tab=t.0). \n",
        "\n",
        "\n",
        "Another possible reason for omission outside of CONUS could be computational challenges or limitations. For instance US territories are subject to different map projections, which implies the need for additional functions in processing algorithms to account for spatial variations and to unify spatial structures.\n",
        "\n",
        "While these limitations explain why Puerto Rico is often left out of national right assessments, these regions are subject to environmental vulnerabilities. This lesson helps address these issues by showing how to **combine demographic data with geospatial boundaries and Low Elevation Coastal Zones (LECZs)** to assess who is most at risk from coastal hazards in **Puerto Rico**.\n",
        "\n",
        "## IPUMS and U.S. Census Geography\n",
        "\n",
        "To support this analysis, we will use data from **IPUMS**, the *Integrated Public Use Microdata Series*. IPUMS is a long-standing data infrastructure project hosted at the **University of Minnesota**, which curates, harmonizes, and provides access to large-scale population and census datasets for research and education.\n",
        "\n",
        "A key IPUMS resource is the **[National Historical Geographic Information System (NHGIS)](https://www.nhgis.org/)**. NHGIS offers tabular census data and matching **geographic boundary files** (e.g., block groups, tracts, counties) going back to the 1790s. These data are essential for conducting spatial analysis of population, housing, and social change.\n",
        "\n",
        "\n",
        "By using the API, you can create **reproducible and automated workflows** to study population vulnerability in places like Puerto Rico—regions that are too often overlooked in national assessments.\n",
        "\n",
        "## Low Elevation Coastal Zones (LECZs)\n",
        "\n",
        "In this lesson, you will assess **who is most exposed** to coastal hazards by combining **demographic data**, **geographic boundaries**, and **Low Elevation Coastal Zones (LECZs)**.\n",
        "\n",
        "LECZs are areas of land located at or below a specified elevation threshold—commonly **5 meters** or **10 meters** above mean sea level. These zones have been globally mapped to estimate population exposure to sea-level rise and storm surge risks [@mcgranahan2007; @macmanus2021].\n",
        "\n",
        "In the **continental United States (CONUS)**, approximately **1 in 10 people** live in the 10m LECZ. Research shows that exposure is not evenly distributed: \n",
        "\n",
        "- **Urban residents**,  \n",
        "- **People of color**, and  \n",
        "- **Older adults**  \n",
        "\n",
        "are **disproportionately** located within these low-lying zones. For example, **1 in 5 urban Black residents** lives in the 10m LECZ [@tagtachian2023; @hauer2020sea].\n",
        "\n",
        "Below is a satellite preview of LECZ coverage in **Puerto Rico**: \n",
        "\n",
        "![](data/images/lecz_pr/lecz_satellite.png)\n",
        "\n",
        " \n",
        "\n",
        "# Accessing Data\n",
        "\n",
        "\n",
        "In this section, you'll load the required Python libraries to work with census data, geospatial files, and visualization tools. These packages allow you to:\n",
        "\n",
        "- Authenticate and extract data from the IPUMS API\n",
        "- Manipulate and analyze tabular and spatial data\n",
        "- Create maps and statistical graphics\n",
        "- Work with ArcGIS-hosted feature layers and Earthdata content\n",
        "\n",
        "Below is the full import block. Core packages are required; others are optional or used for extended functionality.\n"
      ],
      "id": "b9b05957"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import arcgis\n",
        "from arcgis.gis import GIS\n",
        "\n",
        "\n",
        "# Standard libraries\n",
        "import os\n",
        "import glob\n",
        "import re\n",
        "from zipfile import ZipFile\n",
        "\n",
        "from dotenv import load_dotenv\n",
        "\n",
        "import pprint\n",
        "import requests\n",
        "\n",
        "# Data manipulation and plotting\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import matplotlib.colors as colors\n",
        "from matplotlib.ticker import FuncFormatter\n",
        "\n",
        "# Geospatial libraries\n",
        "import geopandas as gpd  \n",
        "from arcgis.features import GeoAccessor, GeoSeriesAccessor\n",
        "from arcgis.raster import Raster\n",
        "import arcgis.mapping  # For using WebMap, MapView, etc.\n",
        "\n",
        "# Earthdata access\n",
        "import earthaccess as ea\n",
        "\n",
        "# IPUMS API and DDI access\n",
        "from ipumspy.api import IpumsApiClient\n",
        "from ipumspy import AggregateDataExtract, readers, ddi\n",
        "\n",
        "from ipumspy import readers, ddi \n",
        "\n",
        "from ipumspy.api.extract import NhgisDataset\n",
        "\n",
        "import seaborn as sns\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "from matplotlib.ticker import FuncFormatter\n",
        "\n",
        "\n",
        "from shapely.geometry import Polygon\n",
        "\n",
        "import folium \n"
      ],
      "id": "e7a3ef0b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This lesson uses `arcgis` version of 2.4.0 or higher:\n"
      ],
      "id": "1ffdb788"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Check the arcgis version for mapping properly \n",
        "arcgis.__version__"
      ],
      "id": "5e399b45",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "If arcgis version is lower, use `pip install`:\n"
      ],
      "id": "b366fc71"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "\n",
        "pip install arcgis==2.4.1.1"
      ],
      "id": "325e5458",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Using IPUMS API to access U.S Census Data for Puerto Rico\n",
        "\n",
        "\n",
        "### Registering to IPUMS and the National Historical Geographic Information System (NHGIS) \n",
        "\n",
        "In order to retrieve an IPUMS API Key, you will have to register for an account for IPUMS and request your [API Key](https://account.ipums.org/api_keys). Additionally you must register to [The National Historical Geographic Information System (NHGIS)](https://uma.pop.umn.edu/nhgis/registration) to access Puerto Rico's ACS data.\n",
        "\n",
        "After you requested your IPUMS API, to the NHGIS, store it in `os.env` format. You will need your registration email and the API Key:\n"
      ],
      "id": "1606d5ca"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        " \n",
        "\n",
        "# # Step 1: Load environment variables\n",
        "# load_dotenv()\n",
        "\n",
        "# # Step 2: Retrieve API key from .env file\n",
        "# IPUMS_API_KEY = os.getenv(\"IPUMS_API_KEY\")  # Replace with your actual key name if different\n",
        "\n",
        "# # Step 3: Validate that the key was loaded\n",
        "# if IPUMS_API_KEY is None:\n",
        "#     raise ValueError(\"API key not found. Ensure 'IPUMS_API_KEY' is set in your .env file.\")\n",
        "\n",
        "# # Step 4: Initialize the IPUMS API client\n",
        "# ipums = IpumsApiClient(IPUMS_API_KEY)"
      ],
      "id": "dfd792f8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "\n",
        "\n",
        "# Step 1: Load API key from .env file\n",
        "load_dotenv()\n",
        "IPUMS_API_KEY = os.getenv(\"jfm2205@columbia.edu\", \"59cba10d8a5da536fc06b59d0f22aac2b5f64a819df686fd2d47d0e4\")\n",
        "\n",
        "if IPUMS_API_KEY is None:\n",
        "    raise ValueError(\"API key not found. Make sure IPUMS_API_KEY is defined in your .env file.\")\n",
        "\n",
        "# Step 2: Initialize IPUMS client\n",
        "ipums = IpumsApiClient(IPUMS_API_KEY)\n"
      ],
      "id": "cb467879",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Downlaoding shapefiles from IPUMS\n",
        "\n",
        "Before downloading spatial data, we need to identify the correct **shapefile name** for our area of interest—in this case, **Puerto Rico block groups for 2010**\n",
        "\n",
        "The code below queries the NHGIS metadata catalog using the IPUMS API and lists matching shapefiles based on geography, level, and year.\n"
      ],
      "id": "4e19e27a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Search IPUMS NHGIS metadata for shapefiles related to Puerto Rico block groups (2010)\n",
        "\n",
        "for page in ipums.get_metadata_catalog(\"nhgis\", metadata_type=\"shapefiles\"):\n",
        "    for shapefile in page[\"data\"]:\n",
        "        if (\n",
        "            shapefile[\"extent\"] == \"Puerto Rico\"\n",
        "            and shapefile[\"geographicLevel\"] == \"Block Group\"\n",
        "            and shapefile[\"year\"] == \"2010\"\n",
        "        ):\n",
        "            print(f\"Name: {shapefile['name']} | Year: {shapefile['year']}\")"
      ],
      "id": "f6993dd1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With this API key, we can extract geospatial data from the IPUMS API. Using the geo level `blck_grp`, we can speicify that we want to extract data at the Block Group level.\n",
        "\n",
        "\n",
        "The `AggregateDataExtract` function specifies the collection to use, in this case NHGIS, give it a human-readable label for the extract request, and requests the 2010 and 2020 Summary File 1 (SF1a) dataset with tables P12 (sex by age) and H3 (vacancy status) at the block group geographic level. It also limits the extract to geographic extent code \"720\" (Puerto Rico).\n",
        "\n",
        "Getting data from 2010 and 2020 with the variables for **5-year Age Groups (P12)** and **Housing (H3)**. \n"
      ],
      "id": "a354a1ae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "\n",
        "# Submit extraction data to IPUMS portal\n",
        "extract = AggregateDataExtract(\n",
        "    collection=\"nhgis\",  # Use NHGIS collection\n",
        "    description=\"Puerto Rico 2010–2020 vacancy\",  # Extract label\n",
        "    datasets=[\n",
        "        NhgisDataset(\n",
        "            name=\"2010_SF1a\",  # 2010 dataset\n",
        "            data_tables=[\"P12\", \"H3\"],  # Tables: sex by age, vacancy\n",
        "            geog_levels=[\"blck_grp\"]  # At block group level\n",
        "        ),\n",
        "        NhgisDataset(\n",
        "            name=\"2020_DHCa\",  # 2020 dataset\n",
        "            data_tables=[\"P12\", \"H3\"],  # Same tables\n",
        "            geog_levels=[\"blck_grp\"]  # Same level\n",
        "        ),\n",
        "    ],\n",
        "    geographic_extents=[\"720\"]  # Puerto Rico only\n",
        "    # shapefiles=[\"720_blck_grp_2020_tl2020\"]  # Optional: include shapefile\n",
        ")\n"
      ],
      "id": "4f6c3431",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This code sends the extract request to IPUMS, prints the unique extract ID so you can track it, and sets up to wait until the extract is finished.\n"
      ],
      "id": "9140dd38"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "\n",
        "# Submit the extract request\n",
        "ipums.submit_extract(extract)  # Send request to IPUMS\n",
        "print(f\"Extract ID: {extract.extract_id}\")  # Print the extract ID\n",
        "\n",
        "# Wait for the extract to finish"
      ],
      "id": "185b6870",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This code sets up the folder where the extract will be saved, creates it if it doesn't already exist, and downloads the extract from IPUMS to that location:\n"
      ],
      "id": "64681531"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "\n",
        "# Download the extract\n",
        "current = os.getcwd()  # Get current working directory\n",
        "DOWNLOAD_DIR = os.path.join(f\"{current}/data/ipums/block\")  # Set download path\n",
        "\n",
        "os.makedirs(DOWNLOAD_DIR, exist_ok=True)  # Create folder if needed\n",
        "\n",
        "ipums.download_extract(extract, download_dir=DOWNLOAD_DIR)  # Download files to folder"
      ],
      "id": "493ff92f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "After downloading the extract, this code navigates to the download directory, identifies the ZIP file containing the CSV data, and inspects its contents. It then locates the specific CSV files for the years 2010 and 2020 using filename patterns, and reads them directly from the ZIP archive into pandas DataFrames—no need to manually unzip anything!\n"
      ],
      "id": "ca08f94e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "current = os.getcwd()  # Get current working directory\n",
        "DOWNLOAD_DIR = os.path.join(f\"{current}/data/ipums/block\")  # Set path to downloaded extract\n",
        "file_list = os.listdir(DOWNLOAD_DIR)  # List files in download folder\n",
        "csv_zip = [f for f in file_list if f.endswith('_csv.zip')] \n",
        "file_list"
      ],
      "id": "a00dd855",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "current = os.getcwd()  # Get current working directory\n",
        "DOWNLOAD_DIR = os.path.join(current, \"data/ipums/block\")  # Path to downloaded extract\n",
        "file_list = os.listdir(DOWNLOAD_DIR)  # List files in download folder\n",
        "\n",
        "# ---- Case 1: ZIP file ----\n",
        "csv_zip = [f for f in file_list if f.endswith('_csv.zip')]\n",
        "\n",
        "if csv_zip:  # If we found a zip file\n",
        "    csv_path = os.path.join(DOWNLOAD_DIR, csv_zip[0])\n",
        "    print(f\"Found zip file: {csv_path}\")\n",
        "\n",
        "    with ZipFile(csv_path) as z:\n",
        "        csv_data = z.namelist()\n",
        "        print(\"Contents of zip:\", csv_data)\n",
        "\n",
        "        # Find the CSVs\n",
        "        file_2020 = next(f for f in csv_data if '2020' in f and f.endswith('.csv'))\n",
        "        file_2010 = next(f for f in csv_data if '2010' in f and f.endswith('.csv'))\n",
        "\n",
        "        # Read into DataFrames\n",
        "        with z.open(file_2020) as f:\n",
        "            df_2020 = pd.read_csv(f)\n",
        "\n",
        "        with z.open(file_2010) as f:\n",
        "            df_2010 = pd.read_csv(f)\n",
        "\n",
        "# ---- Case 2: FOLDER ending in \"_csv\" ----\n",
        "else:\n",
        "    csv_folders = [f for f in file_list if f.endswith('_csv') and os.path.isdir(os.path.join(DOWNLOAD_DIR, f))]\n",
        "    if not csv_folders:\n",
        "        raise FileNotFoundError(\"No _csv.zip file or _csv folder found in the download directory.\")\n",
        "\n",
        "    csv_folder = os.path.join(DOWNLOAD_DIR, csv_folders[0])\n",
        "    print(f\"Found folder: {csv_folder}\")\n",
        "\n",
        "    folder_files = os.listdir(csv_folder)\n",
        "    print(\"Contents of folder:\", folder_files)\n",
        "\n",
        "    # Find and read the CSVs\n",
        "    file_2020 = next(f for f in folder_files if '2020' in f and f.endswith('.csv'))\n",
        "    file_2010 = next(f for f in folder_files if '2010' in f and f.endswith('.csv'))\n",
        "\n",
        "    df_2020 = pd.read_csv(os.path.join(csv_folder, file_2020))\n",
        "    df_2010 = pd.read_csv(os.path.join(csv_folder, file_2010))\n",
        "\n",
        "print(\"Data loaded successfully!\")\n",
        "print(\"2020 shape:\", df_2020.shape)\n",
        "print(\"2010 shape:\", df_2010.shape)"
      ],
      "id": "f5536fe8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Cleaning and processing IPUMS data\n",
        "\n",
        "This section uses NHGIS Codebook file(s) that were automatically included in your data extract to rename cryptic column codes in the 2010 and 2020 datasets to human-readable labels. These codes correspond to census tables on sex by age and housing occupancy. Renaming makes analysis and visualization much easier later in your workflow.\n",
        "\n",
        "Look for the .txt file(s) in the zipped file you downloaded, and they will shed some light on your data.\n"
      ],
      "id": "4ed86988"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# The NHGIS codes are as follows in the documentation which is downloaded from the IPUMS API \n",
        "\n",
        "# Rename columns for dataframe 2020\n",
        "\n",
        "'''    Table 1:     Sex by Age for Selected Age Categories\n",
        "    Universe:    Total population\n",
        "    Source code: P12\n",
        "    NHGIS code:  U7S\n",
        "        U7S001:      Total\n",
        "        U7S002:      Male\n",
        "        U7S003:      Male: Under 5 years\n",
        "        U7S004:      Male: 5 to 9 years\n",
        "        U7S005:      Male: 10 to 14 years\n",
        "        U7S006:      Male: 15 to 17 years\n",
        "        U7S007:      Male: 18 and 19 years\n",
        "        U7S008:      Male: 20 years\n",
        "        U7S009:      Male: 21 years\n",
        "        U7S010:      Male: 22 to 24 years\n",
        "        U7S011:      Male: 25 to 29 years\n",
        "        U7S012:      Male: 30 to 34 years\n",
        "        U7S013:      Male: 35 to 39 years\n",
        "        U7S014:      Male: 40 to 44 years\n",
        "        U7S015:      Male: 45 to 49 years\n",
        "        U7S016:      Male: 50 to 54 years\n",
        "        U7S017:      Male: 55 to 59 years\n",
        "        U7S018:      Male: 60 and 61 years\n",
        "        U7S019:      Male: 62 to 64 years\n",
        "        U7S020:      Male: 65 and 66 years\n",
        "        U7S021:      Male: 67 to 69 years\n",
        "        U7S022:      Male: 70 to 74 years\n",
        "        U7S023:      Male: 75 to 79 years\n",
        "        U7S024:      Male: 80 to 84 years\n",
        "        U7S025:      Male: 85 years and over\n",
        "        U7S026:      Female\n",
        "        U7S027:      Female: Under 5 years\n",
        "        U7S028:      Female: 5 to 9 years\n",
        "        U7S029:      Female: 10 to 14 years\n",
        "        U7S030:      Female: 15 to 17 years\n",
        "        U7S031:      Female: 18 and 19 years\n",
        "        U7S032:      Female: 20 years\n",
        "        U7S033:      Female: 21 years\n",
        "        U7S034:      Female: 22 to 24 years\n",
        "        U7S035:      Female: 25 to 29 years\n",
        "        U7S036:      Female: 30 to 34 years\n",
        "        U7S037:      Female: 35 to 39 years\n",
        "        U7S038:      Female: 40 to 44 years\n",
        "        U7S039:      Female: 45 to 49 years\n",
        "        U7S040:      Female: 50 to 54 years\n",
        "        U7S041:      Female: 55 to 59 years\n",
        "        U7S042:      Female: 60 and 61 years\n",
        "        U7S043:      Female: 62 to 64 years\n",
        "        U7S044:      Female: 65 and 66 years\n",
        "        U7S045:      Female: 67 to 69 years\n",
        "        U7S046:      Female: 70 to 74 years\n",
        "        U7S047:      Female: 75 to 79 years\n",
        "        U7S048:      Female: 80 to 84 years\n",
        "        U7S049:      Female: 85 years and over\n",
        " \n",
        "    Table 2:     Occupancy Status\n",
        "    Universe:    Housing units\n",
        "    Source code: H3\n",
        "    NHGIS code:  U9X\n",
        "        U9X001:      Total\n",
        "        U9X002:      Occupied\n",
        "        U9X003:      Vacant\n",
        "'''\n",
        "\n",
        "\n",
        "rename_2020 = {\n",
        "    \"U7S001\": \"Total_Population\",\n",
        "    \"U7S002\": \"Male\",\n",
        "    \"U7S003\": \"Male: Under 5 years\",\n",
        "    \"U7S004\": \"Male: 5 to 9 years\",\n",
        "    \"U7S005\":      \"Male: 10 to 14 years\",\n",
        "    \"U7S006\":      \"Male: 15 to 17 years\",\n",
        "    \"U7S007\":      \"Male: 18 and 19 years\",\n",
        "    \"U7S008\":      \"Male: 20 years\",\n",
        "    \"U7S009\":      \"Male: 21 years\",\n",
        "    \"U7S010\":      \"Male: 22 to 24 years\",\n",
        "    \"U7S011\":      \"Male: 25 to 29 years\",\n",
        "    \"U7S012\":      \"Male: 30 to 34 years\",\n",
        "    \"U7S013\":      \"Male: 35 to 39 years\",\n",
        "    \"U7S014\":      \"Male: 40 to 44 years\",\n",
        "    \"U7S015\":      \"Male: 45 to 49 years\",\n",
        "    \"U7S016\":      \"Male: 50 to 54 years\",\n",
        "    \"U7S017\":      \"Male: 55 to 59 years\",\n",
        "    \"U7S018\":      \"Male: 60 and 61 years\",\n",
        "    \"U7S019\":      \"Male: 62 to 64 years\",\n",
        "    \"U7S020\":      \"Male: 65 and 66 years\",\n",
        "    \"U7S021\":      \"Male: 67 to 69 years\",\n",
        "    \"U7S022\":      \"Male: 70 to 74 years\",\n",
        "    \"U7S023\":      \"Male: 75 to 79 years\",\n",
        "    \"U7S024\":      \"Male: 80 to 84 years\",\n",
        "    \"U7S025\":      \"Male: 85 years and over\",\n",
        "    \"U7S026\":      \"Female\",\n",
        "    \"U7S027\":      \"Female: Under 5 years\",\n",
        "    \"U7S028\":      \"Female: 5 to 9 years\",\n",
        "    \"U7S029\":      \"Female: 10 to 14 years\",\n",
        "    \"U7S030\":      \"Female: 15 to 17 years\",\n",
        "    \"U7S031\":      \"Female: 18 and 19 years\",\n",
        "    \"U7S032\":      \"Female: 20 years\",\n",
        "    \"U7S033\":      \"Female: 21 years\",\n",
        "    \"U7S034\":      \"Female: 22 to 24 years\",\n",
        "    \"U7S035\":      \"Female: 25 to 29 years\",\n",
        "    \"U7S036\":      \"Female: 30 to 34 years\",\n",
        "    \"U7S037\":      \"Female: 35 to 39 years\",\n",
        "    \"U7S038\":      \"Female: 40 to 44 years\",\n",
        "    \"U7S039\":      \"Female: 45 to 49 years\",\n",
        "    \"U7S040\":      \"Female: 50 to 54 years\",\n",
        "    \"U7S041\":      \"Female: 55 to 59 years\",\n",
        "    \"U7S042\":      \"Female: 60 and 61 years\",\n",
        "    \"U7S043\":      \"Female: 62 to 64 years\",\n",
        "    \"U7S044\":      \"Female: 65 and 66 years\",\n",
        "    \"U7S045\":      \"Female: 67 to 69 years\",\n",
        "    \"U7S046\":      \"Female: 70 to 74 years\",\n",
        "    \"U7S047\":      \"Female: 75 to 79 years\",\n",
        "    \"U7S048\":      \"Female: 80 to 84 years\",\n",
        "    \"U7S049\":      \"Female: 85 years and over\",\n",
        "    \"U9X001\": \"Total_Housing_Units\",\n",
        "    \"U9X002\": \"Occupied\",\n",
        "    \"U9X003\": \"Vacant\"\n",
        "}\n",
        "\n",
        "#Rename columns for dataframe 2010\n",
        "'''    Table 1:     Housing Units\n",
        "    Universe:    Housing units\n",
        "    Source code: H1\n",
        "    NHGIS code:  IFC\n",
        "        IFC001:      Total\n",
        " \n",
        "    Table 2:     Occupancy Status\n",
        "    Universe:    Housing units\n",
        "    Source code: H3\n",
        "    NHGIS code:  IFE\n",
        "        IFE001:      Total\n",
        "        IFE002:      Occupied\n",
        "        IFE003:      Vacant'''\n",
        "\n",
        "rename_2010 = {\n",
        "    \"H76001\": \"Total_Population\",\n",
        "    \"H76002\": \"Male\",\n",
        "    \"H76003\": \"Male: Under 5 years\",\n",
        "    \"H76004\": \"Male: 5 to 9 years\",\n",
        "    \"H76005\":      \"Male: 10 to 14 years\",\n",
        "    \"H76006\":      \"Male: 15 to 17 years\",\n",
        "    \"H76007\":      \"Male: 18 and 19 years\",\n",
        "    \"H76008\":      \"Male: 20 years\",\n",
        "    \"H76009\":      \"Male: 21 years\",\n",
        "    \"H76010\":      \"Male: 22 to 24 years\",\n",
        "    \"H76011\":      \"Male: 25 to 29 years\",\n",
        "    \"H76012\":      \"Male: 30 to 34 years\",\n",
        "    \"H76013\":      \"Male: 35 to 39 years\",\n",
        "    \"H76014\":      \"Male: 40 to 44 years\",\n",
        "    \"H76015\":      \"Male: 45 to 49 years\",\n",
        "    \"H76016\":      \"Male: 50 to 54 years\",\n",
        "    \"H76017\":      \"Male: 55 to 59 years\",\n",
        "    \"H76018\":      \"Male: 60 and 61 years\",\n",
        "    \"H76019\":      \"Male: 62 to 64 years\",\n",
        "    \"H76020\":      \"Male: 65 and 66 years\",\n",
        "    \"H76021\":      \"Male: 67 to 69 years\",\n",
        "    \"H76022\":      \"Male: 70 to 74 years\",\n",
        "    \"H76023\":      \"Male: 75 to 79 years\",\n",
        "    \"H76024\":      \"Male: 80 to 84 years\",\n",
        "    \"H76025\":      \"Male: 85 years and over\",\n",
        "    \"H76026\":      \"Female\",\n",
        "    \"H76027\":      \"Female: Under 5 years\",\n",
        "    \"H76028\":      \"Female: 5 to 9 years\",\n",
        "    \"H76029\":      \"Female: 10 to 14 years\",\n",
        "    \"H76030\":      \"Female: 15 to 17 years\",\n",
        "    \"H76031\":      \"Female: 18 and 19 years\",\n",
        "    \"H76032\":      \"Female: 20 years\",\n",
        "    \"H76033\":      \"Female: 21 years\",\n",
        "    \"H76034\":      \"Female: 22 to 24 years\",\n",
        "    \"H76035\":      \"Female: 25 to 29 years\",\n",
        "    \"H76036\":      \"Female: 30 to 34 years\",\n",
        "    \"H76037\":      \"Female: 35 to 39 years\",\n",
        "    \"H76038\":      \"Female: 40 to 44 years\",\n",
        "    \"H76039\":      \"Female: 45 to 49 years\",\n",
        "    \"H76040\":      \"Female: 50 to 54 years\",\n",
        "    \"H76041\":      \"Female: 55 to 59 years\",\n",
        "    \"H76042\":      \"Female: 60 and 61 years\",\n",
        "    \"H76043\":      \"Female: 62 to 64 years\",\n",
        "    \"H76044\":      \"Female: 65 and 66 years\",\n",
        "    \"H76045\":      \"Female: 67 to 69 years\",\n",
        "    \"H76046\":      \"Female: 70 to 74 years\",\n",
        "    \"H76047\":      \"Female: 75 to 79 years\",\n",
        "    \"H76048\":      \"Female: 80 to 84 years\",\n",
        "    \"H76049\":      \"Female: 85 years and over\",\n",
        "    \"IFC001\": \"Total_Housing\",\n",
        "    \"IFE001\": \"Total_Housing_Units\",\n",
        "    \"IFE002\": \"Occupied\",\n",
        "    \"IFE003\": \"Vacant\"\n",
        "}\n",
        "\n",
        "\n",
        "\n",
        "# Apply renaming to both datasets\n",
        "df_2010.rename(columns=rename_2010, inplace=True)  # Rename 2010 columns\n",
        "df_2020.rename(columns=rename_2020, inplace=True)  # Rename 2020 columns"
      ],
      "id": "d82b8759",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This step filters both datasets to include only records from Puerto Rico, which is identified in the IPUMS data by `STATEA == 72`. It also removes any columns that are completely empty (all values are NaN), which helps clean up the data for analysis.\n"
      ],
      "id": "80fe2768"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Subset Puerto Rico (STATEA code 72)\n",
        "pr_df_2010 = df_2010[df_2010[\"STATEA\"] == 72]  # Filter 2010 data for Puerto Rico\n",
        "pr_df_2020 = df_2020[df_2020[\"STATEA\"] == 72]  # Filter 2020 data for Puerto Rico\n",
        "\n",
        "# Drop columns with all missing values\n",
        "pr_df_2010 = pr_df_2010.dropna(axis=1, how='all')  # Clean 2010 data\n",
        "pr_df_2020 = pr_df_2020.dropna(axis=1, how='all')  # Clean 2020 data"
      ],
      "id": "53e5ed46",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This step calculates the total population aged 60 and over (Population 60+) by summing the relevant male and female age group columns. It then computes two new indicators for both 2010 and 2020:\n",
        "\n",
        "-   `Pop60pRatio`: the share of the total population that is 60+\n",
        "\n",
        "-   `VacantRatio`: the share of housing units that are vacant\n",
        "\n",
        "These ratios help measure aging and housing vacancy patterns in Puerto Rico over time.\n"
      ],
      "id": "704026a5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define age columns for population 60+\n",
        "pop60plus_cols = [\n",
        "    \"Female: 60 and 61 years\",\n",
        "    \"Female: 62 to 64 years\",\n",
        "    \"Female: 65 and 66 years\",\n",
        "    \"Female: 67 to 69 years\",\n",
        "    \"Female: 70 to 74 years\",\n",
        "    \"Female: 75 to 79 years\",\n",
        "    \"Female: 80 to 84 years\",\n",
        "    \"Female: 85 years and over\",\n",
        "    \"Male: 60 and 61 years\",\n",
        "    \"Male: 62 to 64 years\",\n",
        "    \"Male: 65 and 66 years\",\n",
        "    \"Male: 67 to 69 years\",\n",
        "    \"Male: 70 to 74 years\",\n",
        "    \"Male: 75 to 79 years\",\n",
        "    \"Male: 80 to 84 years\",\n",
        "    \"Male: 85 years and over\"\n",
        "]\n",
        "\n",
        "# Calculate totals and ratios for 2010\n",
        "pr_df_2010[\"Pop60plus_total\"] = pr_df_2010[pop60plus_cols].sum(axis=1)  # Sum 60+ pop\n",
        "pr_df_2010[\"Pop60pRatio\"] = pr_df_2010[\"Pop60plus_total\"] / pr_df_2010[\"Total_Population\"]  # 60+ share\n",
        "pr_df_2010[\"VacantRatio\"] = pr_df_2010[\"Vacant\"] / pr_df_2010[\"Total_Housing_Units\"]  # Vacancy share\n",
        "\n",
        "# Calculate totals and ratios for 2020\n",
        "pr_df_2020[\"Pop60plus_total\"] = pr_df_2020[pop60plus_cols].sum(axis=1)\n",
        "pr_df_2020[\"Pop60pRatio\"] = pr_df_2020[\"Pop60plus_total\"] / pr_df_2020[\"Total_Population\"]\n",
        "pr_df_2020[\"VacantRatio\"] = pr_df_2020[\"Vacant\"] / pr_df_2020[\"Total_Housing_Units\"]\n"
      ],
      "id": "c4f6712c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Exploring data with graphs\n",
        "\n",
        "## Compare two variables in Scatterplot\n",
        "\n",
        " To explore the relationship between **Population 60+** and **housing vacancy**, we'll create a **scatter plot** using data from 2010. Each point represents a block group in Puerto Rico:\n",
        "\n",
        "- The **x-axis** shows the **vacant housing ratio** \n",
        "- The **y-axis** shows the **Population 60+ ratio**\n",
        "\n",
        "This kind of visualization helps reveal spatial patterns or clusters related to population 60+ and housing dynamics.\n"
      ],
      "id": "5099db7b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot Aged Ratio vs. Vacant Ratio for 2010\n",
        "plt.scatter(pr_df_2010[\"VacantRatio\"], pr_df_2010[\"Pop60pRatio\"], alpha=0.3)  # Transparent points\n",
        "\n",
        "plt.title(\"Puero Rico Population 60 + Ratio  over Vacancy Ratio, 2010\")  # Plot title\n",
        "plt.xlabel(\"Vacant Ratio\")  # X-axis label\n",
        "plt.ylabel(\"Population 60+ Ratio\")  # Y-axis label\n",
        "plt.grid(True)  # Show grid\n",
        "plt.tight_layout()  # Adjust layout\n",
        "plt.show()  # Display plot"
      ],
      "id": "c3f44111",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generating Population Pyramids\n",
        "\n",
        "Another useful way to analyze popylation is with population pyramids for Puerto Rico using male and female population by age group, based on census block-level data. The pyramid compares the age structure visually between sexes, helping identify trends like population aging or gender imbalances in specific cohorts.\n",
        "\n",
        "Key Steps in the Code:\n",
        "\n",
        "First, Extract age-by-sex columns from the dataset.\n"
      ],
      "id": "07310cfc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define the relevant columns\n",
        "pyramid_columns_2010 = [col for col in pr_df_2010.columns if col.startswith(\"Male:\") or col.startswith(\"Female:\")]\n",
        "pyramid_columns_2020 = [col for col in pr_df_2020.columns if col.startswith(\"Male:\") or col.startswith(\"Female:\")]\n"
      ],
      "id": "f30211ef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can cambine narrow age bands into broader, more interpretable age groups (like 15–19 or 20–24) to improve the readability of the population pyramid. \n",
        "\n",
        "In the plot, we manually add percentages for adjacent rows as the age group label.\n",
        "\n",
        "After combining, it prepares the data for bidirectional horizontal bar plotting by making male values negative (so they show on the left), keeping female values positive (on the right), and creating helper columns for width and placement of bars.\n"
      ],
      "id": "5783b550"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def combine_age_groups(df, male_prefix=\"Male: \", female_prefix=\"Female: \"):\n",
        "    # Define the custom age groupings\n",
        "    age_groups = {\n",
        "        \"Under 5 years\": [\"Under 5 years\"],\n",
        "        \"5 to 9 years\": [\"5 to 9 years\"],\n",
        "        \"10 to 14 years\": [\"10 to 14 years\"],\n",
        "        \"15 to 19 years\": [\"15 to 17 years\", \"18 and 19 years\"],\n",
        "        \"20 to 24 years\": [\"20 years\", \"21 years\", \"22 to 24 years\"],\n",
        "        \"25 to 29 years\": [\"25 to 29 years\"],\n",
        "        \"30 to 34 years\": [\"30 to 34 years\"],\n",
        "        \"35 to 39 years\": [\"35 to 39 years\"],\n",
        "        \"40 to 44 years\": [\"40 to 44 years\"],\n",
        "        \"45 to 49 years\": [\"45 to 49 years\"],\n",
        "        \"50 to 54 years\": [\"50 to 54 years\"],\n",
        "        \"55 to 59 years\": [\"55 to 59 years\"],\n",
        "        \"60 to 64 years\": [\"60 and 61 years\", \"62 to 64 years\"],\n",
        "        \"65 to 69 years\": [\"65 and 66 years\", \"67 to 69 years\"],\n",
        "        \"70 to 74 years\": [\"70 to 74 years\"],\n",
        "        \"75 to 79 years\": [\"75 to 79 years\"],\n",
        "        \"80 to 84 years\": [\"80 to 84 years\"],\n",
        "        \"85 years and over\": [\"85 years and over\"]\n",
        "    }\n",
        "\n",
        "    # Aggregate by age groups\n",
        "    rows = []\n",
        "    for label, group in age_groups.items():\n",
        "        male_cols = [male_prefix + g for g in group if male_prefix + g in df.columns]\n",
        "        female_cols = [female_prefix + g for g in group if female_prefix + g in df.columns]\n",
        "\n",
        "        male_total = df[male_cols].sum().sum() if male_cols else 0\n",
        "        female_total = df[female_cols].sum().sum() if female_cols else 0\n",
        "\n",
        "        rows.append({\n",
        "            \"Age\": label,\n",
        "            \"Male\": male_total,\n",
        "            \"Female\": female_total\n",
        "        })\n",
        "\n",
        "    pyramid = pd.DataFrame(rows)\n",
        "\n",
        "    # Prepare for horizontal bar plotting\n",
        "    pyramid[\"Female_Left\"] = 0\n",
        "    pyramid[\"Female_Width\"] = pyramid[\"Female\"]\n",
        "    pyramid[\"Male_Left\"] = -pyramid[\"Male\"]\n",
        "    pyramid[\"Male_Width\"] = pyramid[\"Male\"]\n",
        "\n",
        "    return pyramid\n"
      ],
      "id": "b873a40a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To prepare for visualizing population structure, we first apply the `combine_age_groups()` function to our cleaned census data for 2010 and 2020. This step transforms narrow age bands into broader, more interpretable categories and reshapes the data for plotting population pyramids.\n"
      ],
      "id": "dc699997"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pyramid_2010 = combine_age_groups(pr_df_2010) #use defined function and apply the dataframe `pr_df_2010`\n",
        "pyramid_2020 = combine_age_groups(pr_df_2020) #use defined function and apply the dataframe `pr_df_2020`"
      ],
      "id": "a6514a95",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The function below creates a horizontal population pyramid to compare Puerto Rico’s population structure in 2010 and 2020. Each bar represents the total population within a given age group, broken down by sex:\n",
        "\n",
        "- Male values are shown on the left .\n",
        "- Female values are shown on the right.\n",
        "- Lighter colors represent 2010, and darker colors represent 2020.\n",
        "\n",
        "Custom axis formatting, color palettes, and layout tweaks are used to enhance visual clarity.\n"
      ],
      "id": "4d76b1a4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Format axis ticks to show positive labels for both male and female sides\n",
        "def abs_tick(x, pos):\n",
        "        return f\"{abs(int(x)):,}\"\n",
        "\n",
        "\n",
        "def plot_pyramid_2010_vs_2020(pyramid_2010, pyramid_2020, title=\"Population Pyramid (2010 vs 2020)\"):\n",
        "    \n",
        "    # Extract age group labels and set bar positions\n",
        "    age_labels = pyramid_2010[\"Age\"]\n",
        "    y = np.arange(len(age_labels))        # One row per age group\n",
        "    bar_height = 0.35                     # Half-height bars for side-by-side comparison\n",
        "\n",
        "\n",
        "    fig, ax = plt.subplots()\n",
        "\n",
        "    # Colors: 2010 (light), 2020 (dark)\n",
        "    male_colors = [\"#c6dbef\", \"#2171b5\"]     # Blues\n",
        "    female_colors = [\"#fdd0a2\", \"#e6550d\"]   # Oranges\n",
        "\n",
        "    # Plot Male bars (left)\n",
        "    ax.barh(y - bar_height, -pyramid_2010[\"Male\"], height=bar_height, color=male_colors[0], label=\"Male 2010\")\n",
        "    ax.barh(y,              -pyramid_2020[\"Male\"], height=bar_height, color=male_colors[1], label=\"Male 2020\")\n",
        "\n",
        "    # Plot Female bars (right)\n",
        "    ax.barh(y - bar_height, pyramid_2010[\"Female\"], height=bar_height, color=female_colors[0], label=\"Female 2010\")\n",
        "    ax.barh(y,              pyramid_2020[\"Female\"], height=bar_height, color=female_colors[1], label=\"Female 2020\")\n",
        "\n",
        "    # Format axes\n",
        "    ax.set_yticks(y - bar_height / 2)\n",
        "    ax.set_yticklabels(age_labels)\n",
        "    # Add vertical axis line at center\n",
        "    ax.axvline(0, color=\"gray\", lw=0.8)\n",
        "    # Format x-axis with absolute values for readability\n",
        "    ax.xaxis.set_major_formatter(FuncFormatter(abs_tick))\n",
        "     # Add light grid lines to x-axis\n",
        "    ax.grid(axis='x', linestyle='--', linewidth=0.5, alpha=0.5)\n",
        "\n",
        "    # Dynamically set x-axis limits based on the largest population value\n",
        "    max_val = max(\n",
        "        pyramid_2010[[\"Male\", \"Female\"]].values.max(),\n",
        "        pyramid_2020[[\"Male\", \"Female\"]].values.max()\n",
        "    )\n",
        "    ax.set_xlim(-max_val * 1.1, max_val * 1.1)\n",
        "\n",
        "    # Add chart title and axis labels\n",
        "    ax.set_title(title)\n",
        "    ax.set_xlabel(\"Population\")\n",
        "    ax.set_ylabel(\"Age Group\")\n",
        "\n",
        "    # Add legend\n",
        "    ax.legend(loc=\"lower right\")\n",
        "\n",
        "    # Adjust layout to prevent label cutoff\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n"
      ],
      "id": "87a6e474",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To generate the population pyramid comparing Puerto Rico in 2010 and 2020, we call the plotting function and pass in the pre-processed DataFrames.\n"
      ],
      "id": "8762874a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot population pyramid comparing Puerto Rico (2010 vs 2020)\n",
        "plot_pyramid_2010_vs_2020(pyramid_2010, pyramid_2020, title=\"Puerto Rico Population Pyramid (2010 vs 2020)\")"
      ],
      "id": "c714e25e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Visualizing Population 60+ in a Single County\n",
        "\n",
        "To compare demographic structure at a finer spatial scale, you can generate a population pyramid for any individual municipio (county) in Puerto Rico. The steps below demonstrate how to do this for Arecibo Municipio.\n"
      ],
      "id": "0b63aafc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#show unique names of COUNTY column\n",
        "print(pr_df_2010[\"COUNTY\"].unique())"
      ],
      "id": "fb33c295",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Select and change the COUNTY you want to plot below:"
      ],
      "id": "3bec8652"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Filter 2010 and 2020 datasets to only include Arecibo Municipio\n",
        "county_df_2010 = pr_df_2010[pr_df_2010[\"COUNTY\"] == \"Arecibo Municipio\"]\n",
        "county_df_2020 = pr_df_2020[pr_df_2020[\"COUNTY\"] == \"Arecibo Municipio\"]\n",
        "\n",
        "# Combine narrow age bands into broader categories for plotting\n",
        "county_pyr_2010 = combine_age_groups(county_df_2010)\n",
        "county_pyr_2020 = combine_age_groups(county_df_2020)\n",
        "\n",
        "#Plot population pyramid for Arecibo Municipio\n",
        "plot_pyramid_2010_vs_2020(county_pyr_2010, county_pyr_2020, \"Arecibo, PR, Population Pyramid (2010 vs 2020)\")"
      ],
      "id": "30350750",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Municipio (County) analysis\n",
        "\n",
        "To compare demographic patterns at the **municipio (county)** level, we need to aggregate block group-level data up to the county level.\n",
        "\n",
        "The code below defines a helper function that:\n",
        "\n",
        "-   Sums total population, housing units, and selected variables by county\n",
        "-   Aggregates all age/sex columns needed for further analysis (like population pyramids)\n"
      ],
      "id": "e35a8397"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define a function to aggregate data from block group to county (municipio) level\n",
        "\n",
        "def aggregate_to_county(df, county_col=\"COUNTY\", male_prefix=\"Male\", female_prefix=\"Female\", additional_cols=None):\n",
        "    if additional_cols is None:\n",
        "        # Specify default columns to aggregate if not provided\n",
        "        additional_cols = [\n",
        "            'Total_Population', 'Total_Housing_Units', \n",
        "            'Occupied', 'Vacant', 'Pop60plus_total'\n",
        "        ]\n",
        "    \n",
        "    # Identify all male and female population columns by prefix\n",
        "    population_cols = [col for col in df.columns if col.startswith(male_prefix) or col.startswith(female_prefix)]\n",
        "    \n",
        "    # Filter to additional columns that actually exist in the input DataFrame\n",
        "    valid_additional_cols = [col for col in additional_cols if col in df.columns]\n",
        "    \n",
        "    # Final list of columns to group and aggregate\n",
        "    group_cols = [county_col] + valid_additional_cols + population_cols\n",
        "\n",
        "    # Group by county and sum all selected columns\n",
        "    df_aggregated = df[group_cols].groupby(county_col, as_index=False).sum()\n",
        "\n",
        "    return df_aggregated"
      ],
      "id": "eda7c38a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we apply the function to both the 2010 and 2020 datasets to produce county-level summaries.\n"
      ],
      "id": "59efd349"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Apply the aggregation function to the 2010 data\n",
        "county_df_2010 = aggregate_to_county(pr_df_2010)\n",
        "\n",
        "# Apply the aggregation function to the 2020 data\n",
        "county_df_2020 = aggregate_to_county(pr_df_2020)\n"
      ],
      "id": "b00a1377",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Merginig Datasets\n",
        "\n",
        "To enable side-by-side comparisons between 2010 and 2020, we merge the two county-level datasets. This allows us to compute changes in key indicators like total population, population 60+, and vacant housing units.\n",
        "\n",
        "We use `\"COUNTY\"` as the merge key (geographic identifier) and apply suffixes to distinguish columns from the two years.\n",
        "\n",
        "The resulting `merged_df` DataFrame contains side-by-side values for both years, using suffixes to distinguish 2010 and 2020 columns.\n"
      ],
      "id": "9b937ff7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Merge 2020 data with selected 2010 columns using GISJOIN\n",
        "merged_df = county_df_2020.merge(\n",
        "    county_df_2010,  \n",
        "    on=\"COUNTY\",  # Join on geographic ID\n",
        "    how=\"inner\",  # Keep only matching rows\n",
        "    suffixes=(\"_2020\", \"_2010\")  # Label columns by year\n",
        ")\n"
      ],
      "id": "351e5590",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Comparing Time Series \n",
        "\n",
        "\n",
        "To evaluate demographic and housing shifts between 2010 and 2020, we calculate both **absolute** and **percentage** changes in key indicators at the county level.\n",
        "\n",
        "This includes:\n",
        "- Total population\n",
        "- Population 60+\n",
        "- Vacant housing units\n",
        "\n",
        "By comparing these metrics across decades, we can detect trends such as **population decline**, **housing vacancy growth**, and shifts in the **share of older adults**.\n",
        "\n",
        "The code below creates new columns in the `merged_df` DataFrame to store the absolute and percent changes for each indicator. Division-by-zero cases are handled safely using `.where()`\n"
      ],
      "id": "801e9552"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Calculate absolute changes between 2010 and 2020\n",
        "merged_df[\"Total_Pop_Change\"] = merged_df[\"Total_Population_2020\"] - merged_df[\"Total_Population_2010\"]  # Change in total population\n",
        "merged_df[\"Pop60plus_Change\"] = merged_df[\"Pop60plus_total_2020\"] - merged_df[\"Pop60plus_total_2010\"]  # Change in 60+ population\n",
        "merged_df[\"Vacant_Change\"] = merged_df[\"Vacant_2020\"] - merged_df[\"Vacant_2010\"]  # Change in vacant units\n",
        "\n",
        "\n",
        "# Avoid division by zero using .where()\n",
        "merged_df[\"Total_Pop_Change_Pct\"] = (\n",
        "    (merged_df[\"Total_Population_2020\"] - merged_df[\"Total_Population_2010\"]) /\n",
        "    merged_df[\"Total_Population_2010\"].where(merged_df[\"Total_Population_2010\"] != 0)\n",
        ") * 100\n",
        "\n",
        "merged_df[\"Pop60plus_Change_Pct\"] = (\n",
        "    (merged_df[\"Pop60plus_total_2020\"] - merged_df[\"Pop60plus_total_2010\"]) /\n",
        "    merged_df[\"Pop60plus_total_2010\"].where(merged_df[\"Pop60plus_total_2010\"] != 0)\n",
        ") * 100\n",
        "\n",
        "merged_df[\"Vacant_Change_Pct\"] = (\n",
        "    (merged_df[\"Vacant_2020\"] - merged_df[\"Vacant_2010\"]) /\n",
        "    merged_df[\"Vacant_2010\"].where(merged_df[\"Vacant_2010\"] != 0)\n",
        ") * 100\n"
      ],
      "id": "84f7e5d9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "By looking more closely at the graphs and comparing vacancy differences between 2010 and 2020, it becomes evident that quantile-based classification may not accurately reflect true differences across areas. In cases with extreme outliers, quantile breaks can distort interpretation.\n",
        "\n",
        "\n",
        "::: {.callout-tip }\n",
        "\n",
        "## Math Refresher\n",
        "\n",
        "A **z-score** tells us how many standard deviations a value is from the mean. A positive z-score means the value is above the mean. A negative z-score means it's below the mean. Z-scores help us compare variables on different scales and identify outliers—typically anything above +2 or below –2 is considered unusually high or low.\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "To better evaluate how unusual each area's change is, we compute **z-scores** for each variable. This standardizes the values by subtracting the mean and dividing by the standard deviation, allowing for comparisons across indicators on a consistent scale.\n"
      ],
      "id": "f20af97d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute means and standard deviations\n",
        "means = merged_df[[\"Pop60plus_Change_Pct\", \"Vacant_Change_Pct\" ]].mean()\n",
        "stds = merged_df[[\"Pop60plus_Change_Pct\", \"Vacant_Change_Pct\" ]].std()\n",
        "\n",
        "# Create z-score columns\n",
        "for var in [\"Pop60plus_Change_Pct\", \"Vacant_Change_Pct\" ]:\n",
        "    z_col = var.replace(\"_Change_Pct\", \"_dz\")\n",
        "    merged_df[z_col] = (merged_df[var] - means[var]) / stds[var]"
      ],
      "id": "395410ff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Plotting Graphs from IPUMS data:\n",
        "\n",
        "To visually explore the relationships between key demographic and housing changes from 2010 to 2020, we use a Seaborn `pairplot()`. This plot creates:\n",
        "\n",
        "- **Scatterplots** for each pair of variables to reveal possible correlations\n",
        "- **Histograms** along the diagonal to show the distribution of each variable\n",
        "\n",
        "This is a quick way to identify patterns such as **population decline**, **growth in the 60+ population**, or **rising housing vacancy** across Puerto Rico’s counties.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "This `pairplot` function uses the z-score standardized versions of the change variables to compare their relative behavior across Block Groups in a **scatterplot matrix**. \n",
        "\n",
        "By putting all variables on the same scale (mean = 0, std = 1), we can asily spot strong linear relationships, identify clusters or outliers, and ompare change intensity across different domains (e.g., aging vs. vacancy).\n",
        "\n",
        "This is especially useful when your original variables had different units or ranges.\n",
        "\n",
        "\n",
        "Can you spot any linear trends in the scatterplots?\n"
      ],
      "id": "6ee84624"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Select key columns to compare\n",
        "plot_vars = [\n",
        "    \"Total_Pop_Change_Pct\",      # % change in total population\n",
        "    \"Pop60plus_Change_Pct\",      # % change in population 60+\n",
        "    \"Vacant_Change_Pct\",         # % change in vacant housing units\n",
        "    \"Total_Population_2020\",     # Population in 2020\n",
        "    \"Total_Population_2010\"      # Population in 2010\n",
        "]\n",
        "\n",
        "# Generate pairwise scatterplots with histograms on the diagonal\n",
        "sns.pairplot(\n",
        "    merged_df[plot_vars],\n",
        "    diag_kind=\"hist\",\n",
        "    corner=True,  # Show only lower triangle\n",
        "    plot_kws=dict(marker=\"o\", facecolors='none', edgecolors='blue')\n",
        ")\n",
        "\n",
        "# Add overall title and adjust layout\n",
        "plt.suptitle(\"Pairwise Scatterplots and Histograms (2010–2020 Changes)\", y=1.02)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "3ca7b406",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Comparing Counties Spatially\n",
        "\n",
        "\n",
        "To fully understand how population and housing trends vary across **Puerto Rico’s counties**, we need to combine *attribute data* (e.g., census population values) with *spatial boundaries*.\n",
        "\n",
        "In this section, we will:\n",
        "- Use the `arcgis` Python package to access a **hosted feature layer** from ArcGIS Online containing county (municipio) geometries for Puerto Rico.\n",
        "- Merge this geometry with our 2010–2020 demographic dataset to form a **Spatially Enabled DataFrame (SEDF)** ready for mapping.\n",
        "- Create an interactive map that classifies counties based on changes in population 60+.\n",
        "- Overlay the **Low Elevation Coastal Zone (LECZ)** polygon layer to highlight which counties intersect with flood-prone coastal zones.\n",
        "- Generate a second map to visualize LECZ exposure and examine spatial patterns.\n",
        "\n",
        "This spatial analysis allows us to move beyond raw tables and visually explore which areas are experiencing population shifts, housing vacancies, and environmental vulnerability in tandem.\n",
        "\n",
        "\n",
        "## Interact with ArcGIS Online Portal\n",
        "\n",
        "To retrieve official county boundaries for Puerto Rico, we use the `arcgis` Python package to access a \"hosted feature layer\" from **ArcGIS Online**. This layer includes U.S. county geometries from the 2020 Census.\n",
        "\n",
        "We filter the layer to include only features where `STATEFP = '72'`, which corresponds to Puerto Rico, and convert the result into a **Spatially Enabled DataFrame (SEDF)** for further analysis.\n"
      ],
      "id": "96833866"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Get the layer from the published data\n",
        "\n",
        "# Connect to ArcGIS Online (anonymous session)\n",
        "gis = GIS()\n",
        "\n",
        "# Access a specific hosted feature layer by its Item ID\n",
        "layer = gis.content.get(\"3132216944b249a08d13b1aa0ee6fda2\").layers[0]  # PR counties 2020 layer\n",
        "\n",
        "# Query Puerto Rico counties using the state FIPS code '72'\n",
        "sedf = layer.query(where=\"STATEFP = '72'\").sdf  # Convert to Spatially Enabled DataFrame"
      ],
      "id": "1eea1331",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can merge the spatial county feature layer for Puerto Rico (2020) with your  demographic data (2010–2020) using the `COUNTY` field as a common geographic identifier. The result, `pr_sedf_ipums`, is a Spatially Enabled DataFrame that contains both geometry and attribute data—making it ready for mapping or spatial analysis!\n"
      ],
      "id": "7a5b6283"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Merge the feature to the merged 2010-2020 df\n",
        "print(\"`merged_df` DataFrame row count before table join: \", len(merged_df))\n",
        "pr_sedf_ipums = sedf.merge(merged_df, left_on=\"NAMELSAD\", right_on=\"COUNTY\", how = \"inner\")\n",
        "\n",
        "print(\"`pr_sedf_ipums` DataFrame results after table join: \", len(pr_sedf_ipums))\n"
      ],
      "id": "4e23247f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that we've merged demographic data with county geometries, we can use `arcgis` to create an interactive **choropleth map**. The map classifies Puerto Rico’s counties based on **z-scores of Population 60+ change** (`Pop60plus_dz`).\n"
      ],
      "id": "71f8edc4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## Set up an interactive map centered on Puerto Rico\n",
        "gis = GIS()\n",
        "m = gis.map(\"Puerto Rico\")\n",
        "\n",
        "# Define classification settings for choropleth\n",
        "num_classes = 5                                      # Number of quantile classes\n",
        "field = \"Pop60plus_dz\"                               # Field to visualize (z-score of 60+ population change)\n",
        "column_values = pr_sedf_ipums[field].dropna()        # Drop missing values\n",
        "\n",
        "# Create class breaks using quantiles\n",
        "breaks = list(np.quantile(column_values, np.linspace(0, 1, num_classes + 1)))\n",
        "\n",
        "# Define a color palette (RdBu reversed)\n",
        "colors = [\"#d73027\", \"#fc8d59\", \"#fee090\", \"#91bfdb\", \"#4575b4\"]\n",
        "\n",
        "# Build a renderer to style the polygons\n",
        "renderer = {\n",
        "    \"type\": \"classBreaks\",\n",
        "    \"field\": field,\n",
        "    \"classificationMethod\": \"esriClassifyQuantile\",\n",
        "    \"minValue\": float(min(column_values)),\n",
        "    \"classBreakInfos\": [\n",
        "        {\n",
        "            \"classMaxValue\": float(breaks[i + 1]),\n",
        "            \"label\": f\"{breaks[i]:.2f} – {breaks[i+1]:.2f}\",\n",
        "            \"description\": \"\",\n",
        "            \"symbol\": {\n",
        "                \"type\": \"esriSFS\",\n",
        "                \"style\": \"esriSFSSolid\",\n",
        "                \"color\": list(int(c.lstrip(\"#\")[i:i+2], 16) for i in (0, 2, 4)) + [180],  # RGBA color\n",
        "                \"outline\": {\n",
        "                    \"color\": [0, 0, 0, 40],\n",
        "                    \"width\": 0.4,\n",
        "                    \"type\": \"esriSLS\",\n",
        "                    \"style\": \"esriSLSSolid\"\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "        for i, c in enumerate(colors)\n",
        "    ]\n",
        "}\n",
        "\n",
        "# Plot the spatial data with the custom renderer\n",
        "pr_sedf_ipums.spatial.plot(\n",
        "    map_widget=m,\n",
        "    renderer=renderer,\n",
        "    legend=True\n",
        ")\n",
        "\n",
        "# Enable legend display\n",
        "m.legend.enabled = True\n",
        "\n",
        "# Display the interactive map\n",
        "m\n"
      ],
      "id": "dac17a58",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Map of relative change in population 60+ in Puerto Rico's Municipios. Red representing high values and blue representing low values.\n",
        "\n",
        "## Low Elevation Coastal Zone Spatial Analysis with IPUMS counties\n",
        "\n",
        "To examine which counties in Puerto Rico are exposed to coastal hazards, we will overlay **LECZ (Low Elevation Coastal Zone)** polygons with our county-level IPUMS data. These polygons identify areas vulnerable to sea-level rise and storm surge—typically defined by elevation thresholds (e.g., 5 or 10 meters).\n",
        "\n",
        "The first step is to search **ArcGIS Online’s Living Atlas** using the `arcgis` Python package to locate an LECZ feature layer for Puerto Rico.\n"
      ],
      "id": "af58182b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Search ArcGIS Online for LECZ feature layers specific to Puerto Rico\n",
        "lecz = gis.content.search(\n",
        "    \"title:Low Elevation Coastal Zone (LECZ) for Puerto Rico\",\n",
        "    item_type=\"Feature\"\n",
        ")\n",
        "\n",
        "# Display search results to verify that relevant layers were found\n",
        "for item in lecz:\n",
        "    display(item)\n",
        "\n",
        "# Select the first matching layer (assumes the most relevant appears first)\n",
        "lecz_layer = lecz[0].layers[0]\n"
      ],
      "id": "96004819",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Once we've identified the appropriate LECZ layer from ArcGIS Online, we query it to retrieve only the polygons where `lecz_zone > 0`. These represent areas that fall within low-elevation thresholds and are considered exposed to coastal flooding or sea-level rise.\n"
      ],
      "id": "8bff555d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Query the selected LECZ layer to extract only the zones with elevation risk\n",
        "# The field `lecz_zone > 0` filters out non-exposed areas (e.g., 0 = not LECZ)\n",
        "lecz_sdf = lecz_layer.query(where=\"lecz_zone > 0\").sdf"
      ],
      "id": "259eb7a6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Map Counties with Population 60+ Change and LECZ Exposure\n",
        "\n",
        "This interactive map overlays two spatial layers:\n",
        "- A **choropleth** of Puerto Rico counties, colored by standardized change in **population 60+** from 2010–2020.\n",
        "- Polygons representing the **Low Elevation Coastal Zone (LECZ)**"
      ],
      "id": "6c88df3c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Set up ArcGIS map centered on Puerto Rico\n",
        "gis = GIS()\n",
        "m = gis.map(\"Puerto Rico\")\n",
        "\n",
        "# Define number of quantile-based classes\n",
        "num_classes = 5\n",
        "field = \"Pop60plus_dz\"  # Z-score of population 60+ change\n",
        "column_values = pr_sedf_ipums[field].dropna()\n",
        "\n",
        "# Generate class breaks using quantiles\n",
        "breaks = list(np.quantile(column_values, np.linspace(0, 1, num_classes + 1)))\n",
        "\n",
        "# Define a reversed RdBu color palette\n",
        "colors = [\"#d73027\", \"#fc8d59\", \"#fee090\", \"#91bfdb\", \"#4575b4\"]\n",
        "\n",
        "# Construct classBreaksRenderer for county layer\n",
        "renderer = {\n",
        "    \"type\": \"classBreaks\",\n",
        "    \"field\": field,\n",
        "    \"classificationMethod\": \"esriClassifyQuantile\",\n",
        "    \"minValue\": float(min(column_values)),\n",
        "    \"classBreakInfos\": [\n",
        "        {\n",
        "            \"classMaxValue\": float(breaks[i + 1]),\n",
        "            \"label\": f\"{breaks[i]:.2f} – {breaks[i+1]:.2f}\",\n",
        "            \"description\": \"\",\n",
        "            \"symbol\": {\n",
        "                \"type\": \"esriSFS\",\n",
        "                \"style\": \"esriSFSSolid\",\n",
        "                \"color\": list(int(c.lstrip(\"#\")[i:i+2], 16) for i in (0, 2, 4)) + [180],  # RGBA\n",
        "                \"outline\": {\n",
        "                    \"color\": [0, 0, 0, 40],\n",
        "                    \"width\": 0.4,\n",
        "                    \"type\": \"esriSLS\",\n",
        "                    \"style\": \"esriSLSSolid\"\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "        for i, c in enumerate(colors)\n",
        "    ]\n",
        "}\n",
        "\n",
        "# Plot county choropleth using the custom renderer\n",
        "pr_sedf_ipums.spatial.plot(\n",
        "    map_widget=m,\n",
        "    renderer=renderer,\n",
        "    legend=True\n",
        ")\n",
        "\n",
        "# Overlay the LECZ polygon layer (unclassified)\n",
        "lecz_sdf.spatial.plot(\n",
        "    map_widget=m\n",
        ")\n",
        "\n",
        "# Enable legend and display the map\n",
        "m.legend.enabled = True\n",
        "m\n"
      ],
      "id": "74cd47dc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "###  Overlay Analysis\n",
        "\n",
        "\n",
        "To assess which counties intersect with **Low Elevation Coastal Zones (LECZs)**, we perform a spatial overlay. This involves:\n",
        "\n",
        "1. Converting both LECZ and county feature layers into **GeoDataFrames** with proper geometries.\n",
        "2. Dissolving the LECZ polygons into a single **MultiPolygon** for simplified spatial comparison.\n",
        "3. Using a **spatial join** to check which counties intersect with LECZ areas.\n",
        "4. Flagging each county with a binary value (`lecz = 1` if exposed, `0` if not).\n",
        "5. Visualizing the results with a **Folium choropleth map**.\n"
      ],
      "id": "8929c083"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        " # Convert SHAPE field to valid Shapely geometry\n",
        "lecz_sdf[\"geometry\"] = lecz_sdf[\"SHAPE\"]\n",
        "pr_sedf_ipums[\"geometry\"] = pr_sedf_ipums[\"SHAPE\"]\n",
        "\n",
        "# Convert both to GeoDataFrames\n",
        "lecz_gdf = gpd.GeoDataFrame(lecz_sdf, geometry=\"geometry\")\n",
        "pr_ipums_gdf = gpd.GeoDataFrame(pr_sedf_ipums, geometry=\"geometry\")\n",
        "\n",
        "# Set projection (Esri Web Mercator)\n",
        "lecz_gdf.set_crs(epsg=3857, inplace=True)\n",
        "pr_ipums_gdf.set_crs(epsg=3857, inplace=True)\n",
        "\n",
        "# Create a single dissolved LECZ polygon (MultiPolygon)\n",
        "lecz_gdf[\"dissolve_id\"] = 1\n",
        "lecz_union_gdf = lecz_gdf.dissolve(by=None)\n"
      ],
      "id": "7b411084",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To determine which counties are geographically exposed to coastal risk, we perform a spatial join with the `sjoin()` function. This operation checks whether each county geometry **intersects** the dissolved LECZ polygon.\n"
      ],
      "id": "63e0fcc4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Perform spatial join: find counties that intersect the dissolved LECZ zone\n",
        "pr_counties_lecz_intersect = gpd.sjoin(\n",
        "    pr_ipums_gdf, lecz_union_gdf, how=\"left\", predicate=\"intersects\"\n",
        ")"
      ],
      "id": "6a0796ff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "After the spatial join, we rename and standardize the LECZ flag column. \n",
        "\n",
        "Counties that intersect the LECZ polygon are assigned `1`; all others are assigned `0`\n"
      ],
      "id": "e402c092"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        " # Rename the joined column to 'lecz' for clarity\n",
        "pr_counties_lecz_intersect = pr_counties_lecz_intersect.rename(columns={\"dissolve_id\": \"lecz\"})\n",
        "\n",
        "# Replace missing values (non-intersections) with 0\n",
        "pr_counties_lecz_intersect[\"lecz\"] = pr_counties_lecz_intersect[\"lecz\"].fillna(0)\n",
        "\n",
        "# Ensure values are binary: convert float 1.0 to integer 1\n",
        "pr_counties_lecz_intersect[\"lecz\"] = pr_counties_lecz_intersect[\"lecz\"].replace(1.0, 1)\n",
        "\n",
        "# Final conversion to integer type\n",
        "pr_counties_lecz_intersect[\"lecz\"] = pr_counties_lecz_intersect[\"lecz\"].astype(int)\n"
      ],
      "id": "545c7e28",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Plot Ovelay Analysis on Map\n",
        "\n",
        "\n",
        "To display the LECZ exposure choropleth in a web map, we:\n",
        "- Reproject to WGS84 (`EPSG:4326`)\n",
        "- Ensure column types are correct\n",
        "- Add a unique string `id` field\n",
        "- Calculate map center for display\n"
      ],
      "id": "837cd884"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Reproject to WGS84 (required for most web maps)\n",
        "gdf = pr_counties_lecz_intersect.to_crs(epsg=4326)\n",
        "\n",
        "# Ensure LECZ flag is binary integer\n",
        "gdf[\"lecz\"] = gdf[\"lecz\"].fillna(0).astype(int)\n",
        "\n",
        "# Add unique string ID column for folium mapping\n",
        "gdf = gdf.reset_index(drop=True)\n",
        "gdf[\"id\"] = gdf.index.astype(str)\n",
        "\n",
        "# Calculate map center from spatial extent\n",
        "minx, miny, maxx, maxy = gdf.total_bounds\n",
        "center = [(miny + maxy) / 2, (minx + maxx) / 2]\n"
      ],
      "id": "1eb2f3f5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We use `folium` to render an interactive **choropleth map** that shows which counties intersect with the **Low Elevation Coastal Zone (LECZ)**. Counties are colored based on a binary indicator: \n",
        "\n",
        "- `1` = exposed to LECZ  \n",
        "- `0` = not exposed\n"
      ],
      "id": "17f5a9a7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Initialize a folium map centered on Puerto Rico\n",
        "m = folium.Map(location=center, zoom_start=8)\n",
        "\n",
        "# Add a choropleth layer based on LECZ exposure\n",
        "folium.Choropleth(\n",
        "    geo_data=gdf,                        # GeoJSON geometry source\n",
        "    data=gdf,                            # Data with values to map\n",
        "    columns=[\"id\", \"lecz\"],              # Key columns (unique ID, value)\n",
        "    key_on=\"feature.properties.id\",      # Match using 'id' property\n",
        "    fill_color=\"PuOr\",                   # Color scheme (purple-orange diverging)\n",
        "    fill_opacity=0.7,                    # Transparency of fill\n",
        "    line_opacity=0.2,                    # Border opacity\n",
        "    legend_name=\"LECZ Zone (1 = Inside, 0 = Outside)\"  # Legend label\n",
        ").add_to(m)\n",
        "\n",
        "# Display the map\n",
        "m"
      ],
      "id": "bb4aa29b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Comparing populations in and out of the LECZ\n",
        "\n",
        "\n",
        "To explore how demographic indicators differ between counties exposed to the **Low Elevation Coastal Zone (LECZ)** and those that are not, we:\n",
        "- Subset relevant columns\n",
        "- Group data by `lecz` status (`1 = inside`, `0 = outside`)\n",
        "- Compute summary statistics for each group\n"
      ],
      "id": "d527b5c9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Step 1: Select columns to include in the analysis\n",
        "cols_to_include = [\"lecz\", \"Total_Population_2020\"] + [\n",
        "    col for col in gdf.columns if col.endswith(\"_Pct\") or col.endswith(\"_dz\")\n",
        "]\n",
        "\n",
        "# Subset and clean the data\n",
        "df = gdf[cols_to_include].dropna()\n",
        "df[\"lecz\"] = df[\"lecz\"].astype(int)\n",
        "\n",
        "# Step 2: Build aggregation dictionary\n",
        "# Start with average total population\n",
        "agg_dict = {\n",
        "    \"Total_Population_2020\": (\"Total_Population_2020\", \"mean\"),\n",
        "}\n",
        "\n",
        "# Add all percentage and z-score columns to be averaged\n",
        "for col in df.columns:\n",
        "    if col.endswith(\"_Pct\") or col.endswith(\"_dz\"):\n",
        "        agg_dict[col] = (col, \"mean\")\n",
        "\n",
        "# Also include a count of counties per group\n",
        "agg_dict[\"count\"] = (\"Total_Population_2020\", \"count\")\n",
        "\n",
        "# Step 3: Group by LECZ (0 = outside, 1 = inside) and compute means\n",
        "summary = df.groupby(\"lecz\").agg(**agg_dict)\n",
        "\n",
        "# Step 4: Rename index values for clarity\n",
        "summary.index = summary.index.map({0: \"Outside LECZ Mean\", 1: \"Inside LECZ Mean\"})\n",
        "\n",
        "# Step 5: Round values for display\n",
        "summary_df = summary.round(2)\n",
        "\n",
        "# Step 6: Compute total population for each group\n",
        "population_sums = df.groupby(\"lecz\")[\"Total_Population_2020\"].sum()\n",
        "population_sums.index = population_sums.index.map({0: \"Outside LECZ\", 1: \"Inside LECZ\"})\n",
        "\n",
        "# Display results\n",
        "print(\"Total Population by LECZ Group:\")\n",
        "print(population_sums)\n",
        "\n",
        "print(\"\\nAverage Demographic and Housing Indicators by LECZ Group:\")\n",
        "print(summary_df)\n"
      ],
      "id": "ea85cd3a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This step uses a Seaborn `pairplot` to explore pairwise relationships among key demographic and housing variables. The scatterplots are grouped by **LECZ exposure (`Inside` vs. `Outside`)**, allowing visual comparison of patterns such as population loss, aging, and housing vacancy.\n"
      ],
      "id": "f5a680d7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Select key variables to include in the pairplot\n",
        "plot_vars = [\n",
        "    \"Total_Pop_Change_Pct\",      # % change in total population (2010–2020)\n",
        "    \"Pop60plus_Change_Pct\",      # % change in 60+ population\n",
        "    \"Vacant_Change_Pct\",         # % change in vacant housing units\n",
        "    \"Total_Population_2020\",     # Total population in 2020\n",
        "    \"Total_Population_2010\",     # Total population in 2010\n",
        "    \"lecz\"                       # LECZ exposure (binary)\n",
        "]\n",
        "\n",
        "# Drop any rows with missing values in selected columns\n",
        "df_pair = gdf[plot_vars].dropna()\n",
        "\n",
        "# Ensure 'lecz' is treated as an integer for grouping\n",
        "df_pair[\"lecz\"] = df_pair[\"lecz\"].astype(int)\n",
        "\n",
        "# Create a readable LECZ label for plotting\n",
        "df_pair[\"LECZ_Label\"] = df_pair[\"lecz\"].map({\n",
        "    0: \"Outside LECZ\",\n",
        "    1: \"Inside LECZ\"\n",
        "})\n",
        "\n",
        "# Create pairwise scatterplots for all selected variables (excluding 'lecz')\n",
        "sns.pairplot(\n",
        "    df_pair,\n",
        "    vars=plot_vars[:-1],          # Exclude 'lecz' from axes\n",
        "    hue=\"LECZ_Label\",             # Color by LECZ category\n",
        "    diag_kind=\"hist\",             # Histogram on diagonal\n",
        "    corner=True,                  # Lower triangle only\n",
        "    plot_kws=dict(marker=\"o\", edgecolor=\"gray\", alpha=0.7)  # Styling\n",
        ")\n",
        "\n",
        "# Add a super title and adjust layout\n",
        "plt.suptitle(\"Pairwise Scatterplots by LECZ\", y=1.02)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "29b6dbbb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### LECZ Population Pyramid Comparison\n",
        "\n",
        " \n",
        "To assess how age structure varies by coastal exposure, we build **two population pyramids**: One for counties **inside** the Low Elevation Coastal Zone (LECZ); One for counties **outside** the LECZ. \n",
        "\n",
        "This allows us to compare how the age distribution—particularly among older populations—differs by exposure to coastal flood risk.\n"
      ],
      "id": "c10f8305"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# ─────────────────────────────────────────\n",
        "# Helper: Combine narrow age bands\n",
        "# ─────────────────────────────────────────\n",
        "def combine_age_groups(df, suffix=\"\", male_prefix=\"Male: \", female_prefix=\"Female: \"):\n",
        "    age_groups = {\n",
        "        \"Under 5 years\": [\"Under 5 years\"],\n",
        "        \"5 to 9 years\": [\"5 to 9 years\"],\n",
        "        \"10 to 14 years\": [\"10 to 14 years\"],\n",
        "        \"15 to 19 years\": [\"15 to 17 years\", \"18 and 19 years\"],\n",
        "        \"20 to 24 years\": [\"20 years\", \"21 years\", \"22 to 24 years\"],\n",
        "        \"25 to 29 years\": [\"25 to 29 years\"],\n",
        "        \"30 to 34 years\": [\"30 to 34 years\"],\n",
        "        \"35 to 39 years\": [\"35 to 39 years\"],\n",
        "        \"40 to 44 years\": [\"40 to 44 years\"],\n",
        "        \"45 to 49 years\": [\"45 to 49 years\"],\n",
        "        \"50 to 54 years\": [\"50 to 54 years\"],\n",
        "        \"55 to 59 years\": [\"55 to 59 years\"],\n",
        "        \"60 to 64 years\": [\"60 and 61 years\", \"62 to 64 years\"],\n",
        "        \"65 to 69 years\": [\"65 and 66 years\", \"67 to 69 years\"],\n",
        "        \"70 to 74 years\": [\"70 to 74 years\"],\n",
        "        \"75 to 79 years\": [\"75 to 79 years\"],\n",
        "        \"80 to 84 years\": [\"80 to 84 years\"],\n",
        "        \"85 years and over\": [\"85 years and over\"]\n",
        "    }\n",
        "\n",
        "    rows = []\n",
        "    for label, group in age_groups.items():\n",
        "        row = {\"Age\": label}\n",
        "        for lecz in [0, 1]:\n",
        "            male_cols = [f\"{male_prefix}{g}{suffix}\" for g in group if f\"{male_prefix}{g}{suffix}\" in df.columns]\n",
        "            female_cols = [f\"{female_prefix}{g}{suffix}\" for g in group if f\"{female_prefix}{g}{suffix}\" in df.columns]\n",
        "\n",
        "            male_total = df[df[\"lecz\"] == lecz][male_cols].sum().sum() if male_cols else 0\n",
        "            female_total = df[df[\"lecz\"] == lecz][female_cols].sum().sum() if female_cols else 0\n",
        "\n",
        "            row[f\"Male_{lecz}\"] = male_total\n",
        "            row[f\"Female_{lecz}\"] = female_total\n",
        "        rows.append(row)\n",
        "\n",
        "    return pd.DataFrame(rows)\n",
        "\n",
        "# ─────────────────────────────────────────\n",
        "# Plot function\n",
        "# ─────────────────────────────────────────\n",
        "def plot_pyramid_stacked_by_lecz(pyr2010, pyr2020): \n",
        "    def abs_tick(x, pos):\n",
        "        return f\"{abs(int(x)):,}\"\n",
        "\n",
        "    age_labels = pyr2010[\"Age\"]\n",
        "    y = np.arange(len(age_labels))\n",
        "    bar_height = 0.4\n",
        "\n",
        "    fig, (ax1, ax2) = plt.subplots(nrows=2,  sharex=True, figsize=(8, 8))\n",
        "\n",
        "    # OUTSIDE LECZ (lecz = 0) — Top\n",
        "    ax1.barh(y - bar_height/2, -pyr2010[\"Male_0\"], height=bar_height, color=\"#c6dbef\", label=\"Male 2010\")\n",
        "    ax1.barh(y + bar_height/2, -pyr2020[\"Male_0\"], height=bar_height, color=\"#2171b5\", label=\"Male 2020\")\n",
        "    ax1.barh(y - bar_height/2, pyr2010[\"Female_0\"], height=bar_height, color=\"#fdd0a2\", label=\"Female 2010\")\n",
        "    ax1.barh(y + bar_height/2, pyr2020[\"Female_0\"], height=bar_height, color=\"#e6550d\", label=\"Female 2020\")\n",
        "    ax1.set_title(\"Puerto Rico Population Pyramid – Outside LECZ\")\n",
        "    ax1.set_yticks(y)\n",
        "    ax1.set_yticklabels(age_labels)\n",
        "    ax1.axvline(0, color=\"gray\", lw=0.8)\n",
        "    ax1.legend(loc=\"lower right\")\n",
        "    ax1.xaxis.set_major_formatter(FuncFormatter(abs_tick))\n",
        "    ax1.grid(axis=\"x\", linestyle=\"--\", linewidth=0.5, alpha=0.5)\n",
        "\n",
        "    # INSIDE LECZ (lecz = 1) — Bottom\n",
        "    ax2.barh(y - bar_height/2, -pyr2010[\"Male_1\"], height=bar_height, color=\"#c6dbef\")\n",
        "    ax2.barh(y + bar_height/2, -pyr2020[\"Male_1\"], height=bar_height, color=\"#2171b5\")\n",
        "    ax2.barh(y - bar_height/2, pyr2010[\"Female_1\"], height=bar_height, color=\"#fdd0a2\")\n",
        "    ax2.barh(y + bar_height/2, pyr2020[\"Female_1\"], height=bar_height, color=\"#e6550d\")\n",
        "    ax2.set_title(\"Puerto Rico Population Pyramid – Inside LECZ\")\n",
        "    ax2.set_yticks(y)\n",
        "    ax2.set_yticklabels(age_labels)\n",
        "    ax2.axvline(0, color=\"gray\", lw=0.8)\n",
        "    ax2.xaxis.set_major_formatter(FuncFormatter(abs_tick))\n",
        "    ax2.set_xlabel(\"Population\")\n",
        "    ax2.grid(axis=\"x\", linestyle=\"--\", linewidth=0.5, alpha=0.5)\n",
        "\n",
        "    max_val = max(\n",
        "        pyr2010[[\"Male_0\", \"Male_1\", \"Female_0\", \"Female_1\"]].values.max(),\n",
        "        pyr2020[[\"Male_0\", \"Male_1\", \"Female_0\", \"Female_1\"]].values.max()\n",
        "    )\n",
        "    ax1.set_xlim(-max_val * 1.1, max_val * 1.1)\n",
        "\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "# ─────────────────────────────────────────\n",
        "# Full execution\n",
        "# ─────────────────────────────────────────\n",
        "# Extract columns by suffix\n",
        "pyr_cols_2010 = [col for col in gdf.columns if col.endswith(\"_2010\") and (col.startswith(\"Male:\") or col.startswith(\"Female:\"))]\n",
        "pyr_cols_2020 = [col for col in gdf.columns if col.endswith(\"_2020\") and (col.startswith(\"Male:\") or col.startswith(\"Female:\"))]\n",
        "\n",
        "# Filter and clean\n",
        "df_2010 = gdf[[\"lecz\"] + pyr_cols_2010].dropna()\n",
        "df_2020 = gdf[[\"lecz\"] + pyr_cols_2020].dropna()\n",
        "\n",
        "# Combine age groups by LECZ\n",
        "pyramid_2010 = combine_age_groups(df_2010, suffix=\"_2010\")\n",
        "pyramid_2020 = combine_age_groups(df_2020, suffix=\"_2020\")\n",
        "\n",
        "# Plot pyramids\n",
        "plot_pyramid_stacked_by_lecz(pyramid_2010, pyramid_2020)"
      ],
      "id": "09bb2011",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Preview the pyramid tables:\n"
      ],
      "id": "8de56044"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#print head shows the first few rows of the table\n",
        "print(pyramid_2010.head(5))\n",
        "\n",
        "print(pyramid_2020.head(5))"
      ],
      "id": "1ce5659f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Discussion \n",
        "\n",
        "Despite gaps and inconsistencies in territorial data, we showed that using open-source data and Python-based workflows makes it feasible to build comparable population pyramids for places in Puerto Rico that fall inside and outside the LECZ and to track change from 2010 to 2020.\n",
        "\n",
        "Puerto Rico’s age structure has shifted markedly. Younger cohorts (roughly under age 50) have shrunk, while older cohorts have held steady or grown, reshaping the pyramid from a more youthful base toward an older, more top-heavy profile. Arecibo Municipio mirrors this island-wide pattern: declines in younger cohorts alongside growth in older cohorts.\n",
        "\n",
        "Standardized (z-score) measures of change in the 60+ population suggest that several coastal counties—especially along the west and southwest—experienced above-average increases relative to inland counties.\n",
        "\n",
        "The LECZ overlay indicates that counties intersecting the LECZ tend to show larger increases in the 60+ population on average. Comparing pyramids for LECZ vs. non-LECZ counties, LECZ counties generally have larger total populations yet show similar demographic shifts: fewer young residents and stable or rising older cohorts.\n",
        "\n",
        "Overall, the patterns are consistent with selective migration: younger adults are more mobile and more likely to move away, while older adults—often with stronger place attachment and fewer labor-market incentives to move—remain, increasing the relative share of older residents in many counties.\n",
        "\n",
        "### Limitations and notes on interpretation\n",
        "\n",
        "Classification choices matter. Quantile breaks can obscure meaningful differences when distributions are skewed; alternative schemes (e.g., natural breaks, equal intervals) or standardization (z-scores) can complement interpretation.\n",
        "\n",
        "LECZ is an exposure proxy, not a loss estimate. It captures low-lying terrain; it does not model storm surge, local defenses, or building elevation.\n",
        "\n",
        "Data harmonization across 2010 and 2020 required table/code matching; any residual inconsistencies (e.g., boundary changes, item definitions) may affect county comparisons.\n",
        "\n",
        "Vacancy can reflect multiple processes (damage, seasonal housing, out-migration); interpreting direction and magnitude should be paired with local knowledge.\n",
        "\n",
        "# Conclusion\n",
        "\n",
        "You’ve just completed a comprehensive, data-rich lesson that explored how to integrate **demographic** and **geospatial** information to understand population vulnerability in Puerto Rico—especially in relation to **Low Elevation Coastal Zones (LECZs)**.\n",
        "\n",
        "Throughout this lesson, we were able to:\n",
        "\n",
        "- Extract detailed **block group–level census data** for Puerto Rico from 2010 and 2020.\n",
        "- Visualize **population pyramids** and track demographic changes, including the increase in the population aged 60 and older.\n",
        "- Merge demographic indicators with **spatial boundaries** from ArcGIS Online to support spatial analysis.\n",
        "- Conduct an **overlay analysis** with LECZ polygons to identify counties most exposed to coastal flooding.\n",
        "- Compare key metrics (e.g., population loss, vacancy, aging) **inside vs. outside** of the LECZ.\n",
        " \n",
        "Coupling small-area demographics with a simple exposure proxy (LECZ) helps reveal who lives in potentially flood-exposed zones and how local population structure is changing—critical context for risk reduction, health services planning, and adaptation.\n"
      ],
      "id": "b6543f36"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}