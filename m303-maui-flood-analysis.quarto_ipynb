{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Flood Watch Report – Maui Heavy Rainfall Analysis\"\n",
        "author: \n",
        "  - \"Kytt MacManus, Raphael Sutiono, Francisco Sanchez, Mykola Dydych, Juan F. Martinez, Ulugbek Medetov\"\n",
        "format: \n",
        "  html \n",
        "bibliography: m303-maui-flood-bibliography.bib\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "On January 16, 2024, a slow-moving rainstorm over Maui, Hawaii led to significant flooding, road closures, and emergency rescues. In this lesson, learners will employ a Python workflow with NASA’s Integrated Multi-satellite Retrievals for GPM (Global Precipitation Measurement) half-hourly rainfall data, MODIS imagery, and drone photographs (from April 2024). Using open-source packages such as earthaccess, xarray, and rasterstats, participants will acquire, analyze, and visualize multi-scale remote sensing data. Then, integrate demographic layers to explore exposure, impacts, and recovery within the disaster-lifecycle framework, as defined by the [Earth Science Information Partners (ESIP)](https://wiki.esipfed.org/Disasters/Disaster_Life_Cycle). \n",
        "\n",
        "Maui’s population profile highlights the importance of this analysis. Around one in five residents of Maui County are seniors (>65), and one in five are children (<18) [@uscensus2024maui] - two demographics that frequently need specialized assistance during emergencies. These groups make up slightly more than 40% of the county's population. Due to high housing costs (median home value of $858K [@uscensus2024maui]) and nearly 10% of the population living below the poverty line, preparedness and recovery capabilities may be limited by financial constraints. The need for culturally sensitive disaster communication tactics is highlighted by the diverse racial makeup, which includes sizable Native Hawaiian/Pacific Islander communities. Together with spatial housing patterns (65% owner-occupied units [@uscensus2024maui]), these demographic characteristics offer crucial background information for evacuation plans, allocating resources, and launching long-term recovery initiatives.\n",
        "\n",
        "### What will learners do?\n",
        "- Authenticate and access **Integrated Multi-satellitE Retrievals for GPM (Global Precipitation Measurements) (IMERG)** precipitation with earthaccess.\n",
        "\n",
        "- Define the Maui **Area of Interest (AOI)** using osmnx and apply spatial subsetting.\n",
        "\n",
        "- Visualize rainfall fields and create **time-step animations** with xarray and matplotlib.\n",
        "\n",
        "- Compare satellite-estimated rainfall with **local gauge observations**.\n",
        "\n",
        "- Retrieve **ACS 2023** tract-level population via the **Census API** and overlay exposure.\n",
        "\n",
        "- Produce reproducible maps, charts, and summary statistics to inform preparedness and recovery.\n",
        "\n",
        "\n",
        "## Learning Objectives\n",
        "\n",
        "By the end of this lesson, you should be able to:\n",
        "\n",
        "  - Understand the meteorological causes and risk factors of flash floods in Maui.\n",
        "  - Access and work with NASA rainfall data using Python.\n",
        "  - Download, preprocess, and visualize gridded satellite rainfall data using Python.\n",
        "  - Compare NASA data and rain gauge data to see similarities.\n",
        "  - Integrate and analyze drone imagery to validate and supplement remote sensing results.\n",
        "  - Access and process U.S. Census tract population data using Python and the Census API.\n",
        "  - Overlay population and rainfall data to identify high-risk communities.\n",
        "  - Visualize spatial and time series data in static maps and animated forms using matplotlib/xarray\n",
        "  - Create a reproducible, automated workflow for spatial disaster analysis.\n",
        "  - Communicate analytical results effectively with charts, summary maps, and recommendations for whom it affects. \n",
        "\n",
        "\n",
        "## Introduction\n",
        "Floods are one of the most destructive and persistent natural hazards, affecting vast populations and resulting in enormous economic losses worldwide. In recent decades, flood occurances have risen, a trend closely linked to human-driven climate change and its impacts on the water cycle [@ceola2022unraveling; @undrr2025garfloods].\n",
        "\n",
        "Increasing global temperatures and more extreme rainfalls are the main drivers behind the growing frequency and intensity of floods. For example, a warmer atmosphere accelerates the hydrologic cycle and produces heavier downpours and higher river flows [@chen2023impacts; @rogers2025role]. Recent large-scale studies estimate that climate change accounts for 21% of the observed rise in global flood exposure, while urbanization—-particularly dense development of people and assets in floodplains—-can account for about 77% of the increase in exposure, with urban and low-income communities facing the greatest exposure [@devitt2023flood; @rogers2025role]. Additional research focused on the United States indicates that rapid coastal urban growth is outpacing flood infrastructure upgrades, creating larger, more densely populated, and more flood-prone settlements, and similar patterns are even more acute in poorer countries where fast development collides with limited capacity to adapt [@swain2020increased; @rentschler2022flood].\n",
        "\n",
        "**Population density** is the number of people living within a given area, such as inhabitants per square kilometer. Sources like national censuses and high-resolution gridded population datasets (for example, the [GHSL - Global Human Settlement Layer](https://human-settlement.emergency.copernicus.eu/), [WorldPop Open Population Repository (WOPR)](https://wopr.worldpop.org/), or [Gridded Population of the World, Version 4 (GPWv4)](https://doi.org/10.7910/DVN/TGGNSU)) can be used to supplement disaster analysis with dynamic information, from mobile phone call records or satellite imagery, to refine where people are actually located.​\n",
        "\n",
        "High population density can greatly intensify the impacts of flooding because a single event affects more residents, more buildings, and more economic activity within the flooded zone, leading to higher total losses [@sanders2024quantifying].​\n",
        "\n",
        "**Flood risk infrastructure** consists of engineered, natural, and other physical systems that aim to reduce how often floods occur and how severe their impacts are. Typical examples include levees, floodwalls, embankments, stormwater drainage networks, retention or detention basins, coastal defenses, and green infrastructure such as wetlands and vegetated buffers, all of which work in different ways to store, redirect, or slow floodwaters [@mcclymont2020flood].​\n",
        "\n",
        "Population density and the quality of flood protection systems stand out as key factors shaping how severe flood losses become. Communities with high population density and high-value assets concentrated in one area face much greater exposure when a single flood occurs [@rogers2025role]. In contrast, well-designed flood infrastructure—such as levees, designated floodways, stormwater drainage, and green adaptation measures—can substantially curb damages, even when hazard levels increase [@fan2025exploring; @wu2021quantifying].\n",
        "\n",
        "![Maui Disaster Assessment](data/images/maui-disaster-assessment.png)\n",
        "Photo of road in Maui, Hawaii post flooding event, 2024.[^1]\n",
        "\n",
        "[^1]: Photo Credit: Kytt MacManus\n",
        "\n",
        "### NASA Global Precipitation Measurement (GPM)\n",
        "\n",
        "The **[Global Precipitation Measurement (GPM) IMERG Final Precipitation L3 Half Hourly 0.1 degree x 0.1 degree V07 (GPM_3IMERGHH)](https://disc.gsfc.nasa.gov/datasets/GPM_3IMERGHH_07/summary)** provides high-resolution multi-satellite precipitation estimates [@huffman2023imerg]. This dataset is produced by the Precipitation Processing System (PPS) at NASA's Goddard Space Flight Center (GSFC) and is distributed through the [Goddard Earth Sciences Data and Information Services Center (GES DISC)](https://disc.gsfc.nasa.gov/datasets/GPM_3IMERGHH_07/summary).\n",
        "\n",
        "\n",
        "\n",
        "### NASA Earthaccess\n",
        " \n",
        "NASA's `earthaccess` is a Python library designed to simplify the process of searching, accessing, and downloading Earth science data from NASA's repositories. It integrates seamlessly with [**NASA's Earthdata Login**](https://urs.earthdata.nasa.gov/) system, allowing users to authenticate and interact with various datasets programmatically.\n",
        "\n",
        "A NASA Earthdata Login profile is required to access Earthdata datasets for this lesson. \n",
        "\n",
        "\n",
        "### Open Street Map\n",
        "\n",
        "[OpenStreetMap (OSM)](https://www.openstreetmap.org/) is a collaborative project that creates a free, editable map of the world, built entirely by a community of mappers. In Python, the osmnx library provides a powerful interface for querying and analyzing OSM data, including administrative boundaries, road networks, and building footprints.\n",
        "\n",
        "In this lesson, we use `osmnx` to retrieve the geographic boundary of Hawaii from OSM and extract its bounding box to spatially filter satellite precipitation data.\n",
        "\n",
        "\n",
        "\n",
        "## Data Analysis\n",
        "\n",
        "::: {.callout-tip style=\"color: #5a7a2b;\"}\n",
        "#### Data Science Review\n",
        "\n",
        "Before beginning, please note that this lesson uses the Python programming language and the following Python packages:\n",
        "\n",
        "\n",
        "-   [`os`](https://docs.python.org/3/library/os.html): Provides a portable way to interact with the operating system, including file system operations and environment variables.\n",
        "\n",
        "-   [`re`](https://docs.python.org/3/library/re.html): Enables powerful string pattern matching and text processing using regular expressions.\n",
        "\n",
        "-   [`datetime`](https://docs.python.org/3/library/datetime.html): Used to manipulate dates and times, including timedelta arithmetic for time-based analysis.\n",
        "\n",
        "-   [`numpy`](https://numpy.org/): Foundational package for scientific computing in Python, supporting array operations and numerical computation.\n",
        "\n",
        "-   [`pandas`](https://pandas.pydata.org/): Offers data structures and functions for handling, analyzing, and visualizing structured data.\n",
        "\n",
        "-   [`xarray`](https://docs.xarray.dev/): Enables working with labeled multi-dimensional arrays, ideal for processing NetCDF and other gridded scientific data.\n",
        "\n",
        "-   [`matplotlib.pyplot`](https://matplotlib.org/stable/api/pyplot_api.html): Core plotting library for generating static, interactive, and animated visualizations in Python.\n",
        "\n",
        "-   [`matplotlib.animation`](https://matplotlib.org/stable/api/animation_api.html): Provides tools for creating animated plots and time series visualizations.\n",
        "\n",
        "-   [`osmnx`](https://osmnx.readthedocs.io/): Enables downloading, visualizing, and analyzing street networks and other OpenStreetMap data.\n",
        "\n",
        "-   [`rasterio.transform`](https://rasterio.readthedocs.io/en/latest/topics/transforms.html): Supports creation and manipulation of geospatial raster transforms for coordinate referencing.\n",
        "\n",
        "-   [`rasterstats`](https://pythonhosted.org/rasterstats/): Computes summary statistics of raster datasets over vector geometries for spatial analysis.\n",
        "\n",
        "-   [`earthaccess`](https://earthaccess.readthedocs.io/): Simplifies NASA Earthdata access by managing authentication and dataset queries in a user-friendly way.\n",
        "\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "Using Python 3.11.14, we can import these packages into the Jupyter environment\n"
      ],
      "id": "42ddba01"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#  \n",
        "# Standard library utilities (files, text, time handling)\n",
        "#  \n",
        "import os                  # Interact with the operating system (paths, files, environment variables)\n",
        "import re                  # Regular expressions for pattern matching in strings\n",
        "from datetime import datetime, timedelta  # Work with dates, times, and time offsets\n",
        "\n",
        "\n",
        "#  \n",
        "# Core scientific and tabular data analysis\n",
        "#  \n",
        "import numpy as np          # Numerical computing with arrays and matrices\n",
        "import pandas as pd         # Tabular data analysis using DataFrames\n",
        "import geopandas as gpd     # Spatial data analysis with georeferenced DataFrames\n",
        "import xarray as xr         # Multidimensional labeled arrays (e.g., gridded climate or satellite data)\n",
        "\n",
        "\n",
        "#  \n",
        "# Visualization and animation\n",
        "#  \n",
        "import matplotlib.pyplot as plt       # Static plotting and visualization\n",
        "import matplotlib.animation as animation  # Create animated visualizations (e.g., time series maps)\n",
        "\n",
        "\n",
        "#  \n",
        "# Street networks and OpenStreetMap data\n",
        "#  \n",
        "import osmnx as ox          # Download and analyze street networks and other OSM features\n",
        "\n",
        "\n",
        "#  \n",
        "# Raster data input/output and spatial analysis\n",
        "#  \n",
        "import rasterio             # Read, write, and process raster (gridded) geospatial data\n",
        "from rasterio.transform import from_origin  # Define georeferencing for raster grids\n",
        "from rasterstats import zonal_stats          # Compute statistics of raster values within vector zones\n",
        "\n",
        "\n",
        "#   \n",
        "# Earth observation and remote data access\n",
        "#  \n",
        "import earthaccess          # Access NASA Earthdata datasets (e.g., satellite precipitation, climate data)\n",
        "\n",
        "\n",
        "#  \n",
        "# HDF5 / NetCDF data backends\n",
        "#  \n",
        "import h5netcdf             # NetCDF interface built on HDF5, compatible with xarray\n",
        "import h5py                 # Low-level access to HDF5 files and datasets\n",
        "\n",
        "\n",
        "#  \n",
        "# Web requests and APIs\n",
        "#  \n",
        "import requests             # Send HTTP requests to web APIs (e.g., Census, data services)\n",
        "\n",
        "\n",
        "from pathlib import Path          # Handle file system paths in a platform-independent way \n",
        "\n",
        "from PIL import Image  # PIL is a dependency of matplotlib, usually already available\n"
      ],
      "id": "8ee46b2a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The earthaccess library simplifies the process of accessing NASA Earthdata by handling authentication and data discovery. Before you can search or download data using earthaccess, you need to authenticate using your Earthdata Login credentials. The `earthaccess.login()` function is the starting point for this process.\n"
      ],
      "id": "8228e98d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        " \n",
        "# Authenticate with Earthdata using your Earthdata Login credentials\n",
        "# This will prompt for username/password or use existing credentials  \n",
        " earthaccess.login()"
      ],
      "id": "6a8aecbc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To retrieve NASA precipitation data for Hawaii using earthaccess, we begin by querying geographic boundary data from OpenStreetMap using osmnx, then extract the bounding box for the region. This bounding box is used to search for GPM IMERG half-hourly precipitation data for a specific date range. \n"
      ],
      "id": "4f553d13"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Query Hawaii boundary from OSM  \n",
        "hawaii = ox.geocode_to_gdf(\"Hawaii, USA\")\n",
        "\n",
        "\n",
        "# Extract bounding box as (lon_min, lat_min, lon_max, lat_max)\n",
        "bbox = hawaii.total_bounds  # [minx, miny, maxx, maxy]\n",
        "bounding_box = (bbox[0], bbox[1], bbox[2], bbox[3])"
      ],
      "id": "5dc068fc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Search for GPM IMERG Half-Hourly Precipitation Data:\n"
      ],
      "id": "cf356422"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Search for GPM IMERG Half-Hourly Level 3 data using earthaccess\n",
        "results = earthaccess.search_data(\n",
        "    short_name=\"GPM_3IMERGHH\",     # Dataset short name\n",
        "    version=\"07\",                  # Dataset version\n",
        "    temporal=(\"2024-01-16\", \"2024-01-17\"),  # Example date range\n",
        "    bounding_box=bounding_box      # Geographic bounding box for Hawaii\n",
        ")\n",
        "\n",
        "# Extract data download links from search results\n",
        "all_urls = [granule.data_links()[0] for granule in results]\n",
        "\n",
        "# Print number of URLs found\n",
        "print(len(all_urls), \"URLs found.\")\n"
      ],
      "id": "2f3639af",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, this code will download and create a list of the file paths of the downloaded data from `earthaccess`:"
      ],
      "id": "47f5a8b4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "#| \n",
        "file_path = earthaccess.download(all_urls)"
      ],
      "id": "53edc3eb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": " "
      },
      "source": [
        "#|include: false\n",
        "\n",
        "\n",
        "\n",
        "folder= r\"/Users/CIESINIT/Documents/tops/TOPSTSCHOOL-disasters/data/2025-07-07-47e9ab\"\n",
        "\n",
        "file_path= [os.path.join(folder, f) for f in os.listdir(folder) if \\\n",
        " os.path.isfile(os.path.join(folder, f))]\n",
        "print(file_path)\n"
      ],
      "id": "9e046614",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Visualizing Precipitation Data\n",
        "\n",
        "Once we’ve downloaded the GPM IMERG precipitation data, we can use `xarray` to open the **NetCDF** file and subset it to the region of interest (in this case, Hawaii). This subset is then visualized using `matplotlib` and xarray’s built-in plotting utilities to generate a precipitation map for the first available half-hourly time step.\n"
      ],
      "id": "e41c8cd0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Display the number of observations (files) found\n",
        "print(len(file_path), \"observations found.\")\n",
        "\n",
        "# Open the selected GPM IMERG dataset (e.g., 16th file in list)\n",
        "with xr.open_dataset(file_path[15], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "\n",
        "    # Subset the precipitation variable to the Hawaii bounding box\n",
        "    precip_subset = ds[\"precipitation\"].sel(\n",
        "        lat=slice(bounding_box[1], bounding_box[3]),\n",
        "        lon=slice(bounding_box[0], bounding_box[2])\n",
        "    )\n",
        "\n",
        "    # Select the first time step and reorient data for plotting\n",
        "    data = precip_subset.isel(time=0)\n",
        "    data = data.transpose(\"lat\", \"lon\")\n",
        "\n",
        "# Create a figure and axis\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Plot the precipitation data\n",
        "data.plot(ax=ax, cmap=\"Blues\", cbar_kwargs={\"label\": \"Precipitation (mm/hr)\"})\n",
        "\n",
        "# Overlay the Hawaii boundary geometry from OSM\n",
        "hawaii.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5)\n",
        "\n",
        "# Add plot labels and formatting\n",
        "plt.title(\"GPM IMERG Precipitation over Hawaii with OSM Boundary\")\n",
        "plt.xlabel(\"Longitude\")\n",
        "plt.ylabel(\"Latitude\")\n",
        "plt.tight_layout()\n",
        "plt.show()\n"
      ],
      "id": "59c74b11",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Animation: Visualizing Half-Hourly Rainfall Over Time\n",
        "\n",
        "To understand how precipitation evolves over time, we can animate the sequence of GPM IMERG half-hourly rainfall images. This animation cycles through each file, extracts the timestamp, overlays the precipitation data on the Hawaii boundary, and renders a smooth temporal visualization using `matplotlib.animation`. This is especially helpful for spotting storm patterns and tracking rainfall intensity across the region.\n"
      ],
      "id": "a0fde8be"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# Initialize the figure\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Load first dataset \n",
        "# Open the first NetCDF file using xarray\n",
        "with xr.open_dataset(file_path[0], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "    \n",
        "    # Subset the precipitation variable by latitude and longitude bounds\n",
        "    data0 = ds[\"precipitation\"].sel(\n",
        "        lat=slice(bounding_box[1], bounding_box[3]),    # min_lat to max_lat\n",
        "        lon=slice(bounding_box[0], bounding_box[2])     # min_lon to max_lon\n",
        "    ).isel(time=0).transpose(\"lat\", \"lon\")              # Select first time step and orient for plotting\n",
        "\n",
        "    # Extract longitude and latitude values as 1D arrays\n",
        "    lon = data0.lon.values\n",
        "    lat = data0.lat.values\n",
        "\n",
        "    # Create 2D meshgrid from lat/lon arrays for plotting\n",
        "    lon2d, lat2d = np.meshgrid(lon, lat)\n",
        "\n",
        "    # Plot the initial frame with pcolormesh and add color shading\n",
        "    mesh = ax.pcolormesh(lon2d, lat2d, data0.values, cmap=\"Blues\", shading=\"auto\")\n",
        "\n",
        "    # Add a colorbar to indicate precipitation scale\n",
        "    cbar = fig.colorbar(mesh, ax=ax, label=\"Precipitation (mm/hr)\")\n",
        "\n",
        "# Overlay the Hawaii boundary outline from OSM data\n",
        "hawaii.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5, zorder=2)\n",
        "\n",
        "# Add static plot title with frame info\n",
        "title_text = ax.set_title(f\"GPM IMERG Precipitation over Hawaii - Frame 1/{len(file_path)}\")\n",
        "\n",
        "# Set axis labels\n",
        "ax.set_xlabel(\"Longitude\")\n",
        "ax.set_ylabel(\"Latitude\")\n",
        "\n",
        "# Auto-adjust layout to prevent overlap of labels and plot\n",
        "plt.tight_layout()\n",
        "\n",
        "# --- Define update function for animation ---\n",
        "\n",
        "def update(frame_index):\n",
        "    # Get the file for the current frame\n",
        "    file = file_path[frame_index]\n",
        "\n",
        "    # Open and subset the current file's data\n",
        "    with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "        data = ds[\"precipitation\"].sel(\n",
        "            lat=slice(bounding_box[1], bounding_box[3]),  # Subset latitude\n",
        "            lon=slice(bounding_box[0], bounding_box[2])   # Subset longitude\n",
        "        ).isel(time=0).transpose(\"lat\", \"lon\")            # Select first time slice and orient for plotting\n",
        "\n",
        "    # Extract filename from full path\n",
        "    filename = os.path.basename(file)\n",
        "\n",
        "    # Use regex to extract date (YYYYMMDD) from filename\n",
        "    match = re.search(r\"3IMERG\\.(\\d{8})\", filename)\n",
        "    date_str = match.group(1)\n",
        "\n",
        "    # Use regex to extract time (HHMM) from filename\n",
        "    match = re.search(r\"(\\d{4}).V07B\", filename)\n",
        "    time_str = match.group(1)\n",
        "    time_str = int(time_str)  # Convert to integer (minutes)\n",
        "\n",
        "    # Convert extracted date/time to a datetime object in Hawaii Standard Time (HST)\n",
        "    try: \n",
        "        datetime_obj = datetime.strptime(date_str, \"%Y%m%d\")           # Parse date string\n",
        "        datetime_obj = datetime_obj + timedelta(minutes=time_str)      # Add minutes offset\n",
        "        datetime_obj = datetime_obj - timedelta(hours=10)              # Convert UTC to HST\n",
        "        timestamp_str = datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S HST\") # Format timestamp string\n",
        "\n",
        "    except ValueError:\n",
        "        # Handle parsing errors\n",
        "        timestamp_str = f\"Invalid time in filename: {time_str}\"\n",
        "\n",
        "    # Update the plot data with the current frame\n",
        "    mesh.set_array(data.values.ravel())\n",
        "\n",
        "    # Update the title with the new timestamp\n",
        "    title_text.set_text(f\"GPM IMERG Precipitation over Hawaii — {timestamp_str}\")\n",
        "\n",
        "    # Return updated elements for blitting\n",
        "    return mesh, title_text\n",
        "\n",
        "# --- Create the animation ---\n",
        "\n",
        "print(\"Creating animation...\")\n",
        "\n",
        "ani = animation.FuncAnimation(\n",
        "    fig,                # Target figure object\n",
        "    update,             # Function to call for each frame\n",
        "    frames=len(file_path), # Total number of frames (data files)\n",
        "    interval=200,       # Delay between frames in milliseconds\n",
        "    blit=True,          # Only redraw changed elements for efficiency\n",
        "    repeat=False        # Stop at the last frame\n",
        ")\n",
        "\n",
        "# --- Save the animation as a GIF ---\n",
        "\n",
        "ani.save(\"data/images/hawaii_precip.gif\", writer=\"pillow\", fps=3)  # Save at 3 frames per second\n"
      ],
      "id": "4b23efc7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Hawaii GIF](data/images/hawaii_precip.gif)\n",
        "\n",
        " \n",
        "#### Focusing on Maui\n",
        "\n",
        "To focus analysis on our location of analysis, we use `osmnx` to retrieve the geographic boundary for Maui County, Hawaii from **OpenStreetMap**. We then extract its bounding box and apply a small buffer (0.1 degrees) to ensure that nearby data just outside the strict boundary is included. This padded extent will be used to spatially filter satellite precipitation data or other geospatial layers relevant to the region.\n"
      ],
      "id": "ef9cbe0b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Get the geometry for Maui County, Hawaii from OpenStreetMap\n",
        "maui = ox.geocode_to_gdf(\"Maui County, Hawaii, USA\").to_crs(\"EPSG:4326\")\n",
        "\n",
        "# Extract the bounding box of Maui County as (minx, miny, maxx, maxy)\n",
        "bounding_box = maui.total_bounds\n",
        "\n",
        "# Define a small padding buffer (in degrees) around the bounding box\n",
        "pad = 0.1  # ~0.1 degrees ≈ 5–6 km buffer\n",
        "\n",
        "# Compute padded latitude and longitude boundaries\n",
        "lat_min = bounding_box[1] - pad  # Southern boundary\n",
        "lat_max = bounding_box[3] + pad  # Northern boundary\n",
        "lon_min = bounding_box[0] - pad  # Western boundary\n",
        "lon_max = bounding_box[2] + pad  # Eastern boundary\n"
      ],
      "id": "9a1d4ffb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "After defining the padded bounding box for Maui, we can visualize GPM IMERG half-hourly precipitation data for that area. This plot overlays satellite-derived rainfall intensity on the island’s geographic outline using `xarray` and `matplotlib`, providing spatial context for localized precipitation events.\n"
      ],
      "id": "f4f66be6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Open the 16th GPM IMERG data file and extract the \"Grid\" group\n",
        "with xr.open_dataset(file_path[15], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "    \n",
        "    # Subset the precipitation variable using the padded Maui bounding box\n",
        "    precip_subset = ds[\"precipitation\"].sel(\n",
        "        lat=slice(lat_min, lat_max),   # Latitude range from bounding box\n",
        "        lon=slice(lon_min, lon_max)    # Longitude range from bounding box\n",
        "    )\n",
        "\n",
        "    # Select the first time step in the file\n",
        "    data = precip_subset.isel(time=0)\n",
        "\n",
        "    # Rearrange dimensions for plotting: lat first, then lon\n",
        "    data = data.transpose(\"lat\", \"lon\")\n",
        "\n",
        "# Initialize figure and axis for the plot\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Plot the precipitation data on the map\n",
        "data.plot(ax=ax, cmap=\"Blues\", cbar_kwargs={\"label\": \"Precipitation (mm/hr)\"})\n",
        "\n",
        "# Overlay the Maui County boundary using OSM data\n",
        "maui.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5)\n",
        "\n",
        "# Add plot title and axis labels\n",
        "plt.title(\"GPM IMERG Precipitation over Hawaii with OSM Boundary\")\n",
        "plt.xlabel(\"Longitude\")\n",
        "plt.ylabel(\"Latitude\")\n",
        "\n",
        "# Adjust layout to prevent overlap\n",
        "plt.tight_layout()\n",
        "\n",
        "# Display the plot\n",
        "plt.show()\n"
      ],
      "id": "034756f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To visualize how rainfall evolves across Maui County, this animation cycles through a sequence of GPM IMERG half-hourly datasets. For each frame, it subsets the data to the Maui region, overlays the county boundary, and updates the timestamp extracted from the filename. The animation is then saved as a `.gif` for easy sharing and visual analysis.\n"
      ],
      "id": "f2903cd0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# Initialize the figure and axis for the animation\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Inform the user that we're starting the first frame setup\n",
        "print(\"Initializing plot with first data file...\")\n",
        "\n",
        "# Extract longitude and latitude from the preloaded 'data' array\n",
        "lon = data.lon.values                       # 1D longitude array\n",
        "lat = data.lat.values                       # 1D latitude array\n",
        "\n",
        "# Create 2D coordinate grids from the lat/lon arrays\n",
        "lon2d, lat2d = np.meshgrid(lon, lat)\n",
        "\n",
        "# Create the first pcolormesh using initial data values\n",
        "mesh = ax.pcolormesh(\n",
        "    lon2d, lat2d, data.values,              # Coordinates and initial data\n",
        "    cmap=\"Blues\", shading=\"auto\"           # Colormap and smoothing style\n",
        ")\n",
        "\n",
        "# Add a colorbar to show precipitation intensity\n",
        "cbar = fig.colorbar(mesh, ax=ax, label=\"Precipitation (mm/hr)\")\n",
        "\n",
        "# Overlay Maui County's boundary for spatial context\n",
        "maui.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5, zorder=2)\n",
        "\n",
        "# Set static elements for the plot: title and axis labels\n",
        "title_text = ax.set_title(f\"GPM IMERG Precipitation over Hawaii - Frame 1/{len(file_path)}\")\n",
        "ax.set_xlabel(\"Longitude\")\n",
        "ax.set_ylabel(\"Latitude\")\n",
        "plt.tight_layout()  # Optimize spacing to prevent overlap\n",
        "\n",
        "# --- Define the animation update function ---\n",
        "\n",
        "def update(frame_index):\n",
        "    # Get the file corresponding to the current animation frame\n",
        "    file = file_path[frame_index]\n",
        "\n",
        "    # Open and subset the dataset for Maui bounding box\n",
        "    with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "        data = ds[\"precipitation\"].sel(\n",
        "            lat=slice(lat_min, lat_max),   # Subset latitude\n",
        "            lon=slice(lon_min, lon_max)    # Subset longitude\n",
        "        ).isel(time=0).transpose(\"lat\", \"lon\")  # Select first timestep and rearrange dimensions\n",
        "\n",
        "    # Extract the base filename (no directory)\n",
        "    filename = os.path.basename(file)\n",
        "\n",
        "    # Extract date string (YYYYMMDD) from filename using regex\n",
        "    match = re.search(r\"3IMERG\\.(\\d{8})\", filename)\n",
        "    date_str = match.group(1)\n",
        "\n",
        "    # Extract time offset (HHMM in minutes) from filename\n",
        "    match = re.search(r\"(\\d{4}).V07B\", filename)\n",
        "    time_str = match.group(1)\n",
        "    time_str = int(time_str)  # Convert to integer\n",
        "\n",
        "    # Attempt to convert extracted date and time to formatted timestamp\n",
        "    try: \n",
        "        datetime_obj = datetime.strptime(date_str, \"%Y%m%d\")       # Parse date\n",
        "        datetime_obj += timedelta(minutes=time_str)                # Add time offset\n",
        "        datetime_obj -= timedelta(hours=10)                        # Convert from UTC to HST\n",
        "        timestamp_str = datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S HST\")  # Format timestamp\n",
        "    except ValueError:\n",
        "        # Handle invalid or missing time values\n",
        "        timestamp_str = f\"Invalid time in filename: {time_str}\"\n",
        "\n",
        "    # Update plot with new data values and title\n",
        "    mesh.set_array(data.values.ravel())  # Flatten the data into 1D for pcolormesh\n",
        "    title_text.set_text(f\"GPM IMERG Precipitation over Hawaii — {timestamp_str}\")\n",
        "\n",
        "    return mesh, title_text  # Return updated elements for blitting\n",
        "\n",
        "# --- Generate the animation ---\n",
        "\n",
        "print(\"Creating animation...\")\n",
        "\n",
        "ani = animation.FuncAnimation(\n",
        "    fig,            # The figure object to update\n",
        "    update,         # The update function called per frame\n",
        "    frames=len(file_path),  # Number of frames = number of files\n",
        "    interval=200,   # Delay between frames (ms)\n",
        "    blit=True,      # Use blitting for efficient updates\n",
        "    repeat=False    # Run only once\n",
        ")\n",
        "\n",
        "# --- Save the animation as a GIF ---\n",
        "\n",
        "ani.save(\"data/images/maui_precip.gif\", writer=\"pillow\", fps=3)  # Save to file at 3 frames per second"
      ],
      "id": "b72748d0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Maui GIF](data/images/maui_precip.gif)\n",
        "\n",
        "### Extracting Time Series of Mean Precipitation Over Maui\n",
        "\n",
        "\n",
        "We can use the GPM IMERG half-hourly precipitation files to calculates the mean rainfall over Maui County for each timestep. The data is spatially subset to the OSM Maui bounding box, rasterized using a *geographic transform*, and then aggregated over the island polygon using the function `zonal_stats`. Results are compiled into a *DataFrame* for further analysis or plotting.\n"
      ],
      "id": "7b92b05d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Prepare an empty list to store the results for each file\n",
        "results = []\n",
        "\n",
        "# Loop through each file in the downloaded GPM IMERG dataset\n",
        "for file in file_path:\n",
        "    try:\n",
        "        # --- Open and subset precipitation data ---\n",
        "        with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "            # Select and subset precipitation for Maui bounding box\n",
        "            data = ds[\"precipitation\"].sel(\n",
        "                lat=slice(lat_min, lat_max),     # Latitude bounds\n",
        "                lon=slice(lon_min, lon_max)      # Longitude bounds\n",
        "            ).isel(time=0).transpose(\"lat\", \"lon\")  # First timestep and axis order for raster analysis\n",
        "\n",
        "        # --- Build affine transform for georeferencing raster ---\n",
        "        lats = data[\"lat\"].values              # Latitude array\n",
        "        lons = data[\"lon\"].values              # Longitude array\n",
        "        res_x = lons[1] - lons[0]              # Pixel width\n",
        "        res_y = lats[1] - lats[0]              # Pixel height (note: no flip needed if ordered from top to bottom)\n",
        "        transform = from_origin(\n",
        "            west=lons.min(),                   # Western edge\n",
        "            north=lats.max(),                  # Northern edge\n",
        "            xsize=res_x,                       # Horizontal resolution\n",
        "            ysize=res_y                        # Vertical resolution\n",
        "        )\n",
        "\n",
        "        # --- Extract raw array of precipitation values ---\n",
        "        arr = data.values                      # 2D array (lat × lon)\n",
        "\n",
        "        # --- Parse datetime from filename ---\n",
        "        filename = os.path.basename(file)      # Extract base filename\n",
        "        match_date = re.search(r\"3IMERG\\.(\\d{8})\", filename)   # Extract date string (YYYYMMDD)\n",
        "        match_min = re.search(r\"\\.(\\d{4,5})\\.V\", filename)     # Extract time in minutes\n",
        "\n",
        "        if match_date and match_min:\n",
        "            date_str = match_date.group(1)\n",
        "            mins_str = match_min.group(1)\n",
        "            dt = datetime.strptime(date_str, \"%Y%m%d\") + timedelta(minutes=int(mins_str))  # Combine date and time\n",
        "            dt = dt - timedelta(hours=10)      # Convert from UTC to Hawaii Standard Time\n",
        "        else:\n",
        "            dt = None                          # Fallback if parsing fails\n",
        "\n",
        "        # --- Compute zonal mean over the Maui polygon ---\n",
        "        stats = zonal_stats(\n",
        "            maui,                              # Polygon geometry\n",
        "            arr,                               # Raster array\n",
        "            affine=transform,                  # Spatial transform\n",
        "            stats=\"mean\",                      # Compute mean value\n",
        "            nodata=np.nan                      # Handle missing values\n",
        "        )[0]\n",
        "\n",
        "        # Extract mean precipitation value from the stats result\n",
        "        mean_precip = stats[\"mean\"]\n",
        "\n",
        "        # Append timestamp and mean to results list\n",
        "        results.append({\n",
        "            \"datetime\": dt,\n",
        "            \"mean_precip\": mean_precip\n",
        "        })\n",
        "\n",
        "    except Exception as e:\n",
        "        # Catch and report any errors (e.g., malformed file or data)\n",
        "        print(f\"Skipping file {file} due to error: {e}\")\n",
        "\n",
        "# --- Convert results list to a clean DataFrame ---\n",
        "results_df = pd.DataFrame(results)  # Each row: [datetime, mean_precip]\n",
        "\n",
        "results_df = results_df.sort_values(by=\"datetime\")\n"
      ],
      "id": "dec1278e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that we’ve extracted mean precipitation values for each GPM IMERG file, we can visualize how rainfall changes over time across Maui County. This line plot presents a temporal snapshot of precipitation intensity, helping to identify storm events, rainfall variability, and dry periods.\n"
      ],
      "id": "892b29a3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create the time series line plot\n",
        "plt.figure(figsize=(12, 6))  # Set figure size for clarity and legibility\n",
        "\n",
        "# Plot datetime vs. mean precipitation with markers and connecting lines\n",
        "plt.plot(results_df['datetime'], results_df['mean_precip'], marker='o', linestyle='-')\n",
        "\n",
        "# Add a title and axis labels to describe the plot\n",
        "plt.title('Mean Precipitation Over Maui County Half-Hour Time Series')     # Plot title\n",
        "plt.xlabel('Date and Time (HST)')                                 # X-axis label\n",
        "plt.ylabel('Mean Precipitation')                                  # Y-axis label (units assumed mm/hr)\n",
        "\n",
        "# Automatically format x-axis to prevent overlapping date labels\n",
        "plt.gcf().autofmt_xdate()  # Rotate and align date labels on the x-axis\n",
        "\n",
        "# Add a dashed grid to the background for easier reading\n",
        "plt.grid(True, linestyle='--', alpha=0.7)  # Enable grid with light dashed lines\n",
        "\n",
        "# Adjust spacing to prevent overlapping elements\n",
        "plt.tight_layout()\n",
        "\n",
        "# Display the plot in the output cell\n",
        "plt.show()"
      ],
      "id": "7ad4f28a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Comparing IMERG Sattelite data and Oberved Precipitation data\n",
        "\n",
        "The data for this report comes from the Kahului Airport and downloaded from [WeatherSpark](https://weatherspark.com/h/d/150359/2024/1/16/Historical-Weather-on-Tuesday-January-16-2024-in-Maui-Hawaii-United-States#metar-00-14).\n"
      ],
      "id": "04a6bcba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load your CSV (update with your actual file path)\n",
        "obs_df = pd.read_csv(\"data/maui_rain/maui_rain_gauge_Jan2024.csv\")\n",
        " \n",
        "\n",
        "# Parse datetime\n",
        "obs_df[\"datetime\"] = pd.to_datetime(obs_df[\"Date\"] + \" \" + obs_df[\"Time\"])\n",
        "\n",
        "# Convert precipitation to float\n",
        "obs_df[\"obs_precip\"] = obs_df[\"Precipitation\"].str.replace(\" in\", \"\", regex=False).astype(float)\n"
      ],
      "id": "44b67432",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Plot the data with dual y-axis without proportional scaling to visually compare the two datasets.\n"
      ],
      "id": "c2b141ee"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Make sure datetime columns are parsed\n",
        "obs_df[\"datetime\"] = pd.to_datetime(obs_df[\"Date\"] + \" \" + obs_df[\"Time\"])\n",
        "obs_df[\"obs_precip\"] = obs_df[\"Precipitation\"].str.replace(\" in\", \"\", regex=False).astype(float)\n",
        "\n",
        "results_df[\"datetime\"] = pd.to_datetime(results_df[\"datetime\"])\n",
        "\n",
        "# Create the plot\n",
        "fig, ax1 = plt.subplots(figsize=(12, 6))\n",
        "\n",
        "# Plot observed precipitation on left y-axis\n",
        "line1, = ax1.plot(\n",
        "    obs_df[\"datetime\"], obs_df[\"obs_precip\"],\n",
        "    label=\"Observed (inches)\", color=\"tab:blue\", marker=\"o\"\n",
        ")\n",
        "ax1.set_ylabel(\"Precipitation (inches)\", color=\"tab:blue\")\n",
        "ax1.tick_params(axis='y', labelcolor=\"tab:blue\")\n",
        "\n",
        "# Create right y-axis\n",
        "ax2 = ax1.twinx()\n",
        "\n",
        "# Plot IMERG precipitation on right y-axis (assumed in mm)\n",
        "line2, = ax2.plot(\n",
        "    results_df[\"datetime\"], results_df[\"mean_precip\"],\n",
        "    label=\"IMERG (mm)\", color=\"tab:green\", marker=\"x\", linestyle=\"--\"\n",
        ")\n",
        "ax2.set_ylabel(\"Precipitation (mm)\", color=\"tab:green\")\n",
        "ax2.tick_params(axis='y', labelcolor=\"tab:green\")\n",
        "\n",
        "# Combine legends\n",
        "lines = [line1, line2]\n",
        "labels = [line.get_label() for line in lines]\n",
        "ax1.legend(lines, labels, loc=\"upper left\")\n",
        "\n",
        "# Formatting\n",
        "plt.title(\"Observed vs IMERG Precipitation\")\n",
        "ax1.set_xlabel(\"Datetime\")\n",
        "fig.autofmt_xdate()\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()\n"
      ],
      "id": "1e9d92ce",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Integrating Maui Census Tract Data\n",
        "\n",
        "This section downloads the latest census tract shapefile for Hawaii and loads it as a GeoDataFrame.\n"
      ],
      "id": "ed284ac6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "shapefile_zip = \"data/maui_rain/tl_2023_15_tract.zip\"\n",
        "shapefile_dir = \"data/maui_rain/tl_2023_15_tract\""
      ],
      "id": "4bd016cf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# Set URLs and file paths\n",
        "tiger_url = \"https://www2.census.gov/geo/tiger/TIGER2023/TRACT/tl_2023_15_tract.zip\"\n",
        "\n",
        "\n",
        "\n",
        "# Ensure the directory exists\n",
        "os.makedirs(os.path.dirname(shapefile_zip), exist_ok=True)\n",
        "\n",
        "# Download and extract if not already present\n",
        "if not os.path.exists(shapefile_dir):\n",
        "    r = requests.get(tiger_url, verify=False)\n",
        "    with open(shapefile_zip, 'wb') as f:\n",
        "        f.write(r.content)\n",
        "    with zipfile.ZipFile(shapefile_zip, 'r') as zip_ref:\n",
        "        zip_ref.extractall(shapefile_dir)"
      ],
      "id": "7ba3e44a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load shapefile\n",
        "tracts = gpd.read_file(os.path.join(shapefile_dir, 'tl_2023_15_tract.shp'))"
      ],
      "id": "11a2d696",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Fetch ACS 2023 Population Data for Maui Tracts\n",
        "\n",
        "This section retrieves the latest census population data for Maui tracts and merges it with the shapefile.\n"
      ],
      "id": "83a6f5ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "\n",
        "# Provide your Census API key\n",
        "API_KEY = \"API_KEY\"\n",
        "acs_url = (\n",
        "    \"https://api.census.gov/data/2023/acs/acs5\"\n",
        "    \"?get=NAME,B01003_001E&for=tract:*&in=state:15+county:009\"\n",
        "    f\"&key={API_KEY}\"\n",
        ")\n",
        "\n",
        "response = requests.get(acs_url)"
      ],
      "id": "2090c19c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "\n",
        "\n",
        "\n",
        "# Provide your Census API key\n",
        "API_KEY = \"4c4fb31afba1ae4fbf35b9f8a0d0d65e0432f6e9\"\n",
        "acs_url = (\n",
        "    \"https://api.census.gov/data/2023/acs/acs5\"\n",
        "    \"?get=NAME,B01003_001E&for=tract:*&in=state:15+county:009\"\n",
        "    f\"&key={API_KEY}\"\n",
        ")\n",
        "\n",
        "response = requests.get(acs_url)"
      ],
      "id": "0e75400e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Combining Census data with TIGER shapes\n",
        "\n",
        "This code converts a Census API JSON response into a pandas DataFrame and constructs a geographic identifier (GEOID) by concatenating state, county, and tract codes. It then joins the Census population data to a GeoDataFrame of census tracts using the GEOID as a key. Finally, it ensures the population values are numeric so they can be used reliably in analysis and mapping.\n"
      ],
      "id": "cd98f4f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "census_data = response.json()\n",
        "census_df = pd.DataFrame(census_data[1:], columns=census_data[0])\n",
        "census_df['GEOID'] = census_df['state'] + census_df['county'] + census_df['tract']\n",
        "\n",
        "# Merge population data with tracts\n",
        "tracts = tracts.merge(\n",
        "    census_df[['GEOID', 'B01003_001E']],\n",
        "    on='GEOID',\n",
        "    how='left'\n",
        ")\n",
        "tracts['B01003_001E'] = pd.to_numeric(tracts['B01003_001E'])"
      ],
      "id": "f63bb477",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can use the IMERG files to find a precipitation range, then use that range to keep a consistent (log-scaled) color normalization across time frames. \n",
        "\n",
        "We can plot an animated precipitation raster over Maui and overlays census tracts colored by population, updating the raster and the timestamped title for each frame. Finally, it saves the result as a GIF.\n"
      ],
      "id": "43ba7fb6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "global_min, global_max = np.inf, -np.inf\n",
        "for file in file_path:\n",
        "    with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "        precip = ds[\"precipitation\"].sel(\n",
        "            lat=slice(lat_min, lat_max),\n",
        "            lon=slice(lon_min, lon_max)\n",
        "        ).isel(time=0).transpose(\"lat\", \"lon\")\n",
        "        current_min = precip.min().item()\n",
        "        current_max = precip.max().item()\n",
        "        if np.isfinite(current_min): global_min = min(global_min, current_min)\n",
        "        if np.isfinite(current_max): global_max = max(global_max, current_max)\n",
        "\n",
        "# Optional: Use a LogNorm to enhance contrast\n",
        "from matplotlib.colors import LogNorm\n",
        "norm = LogNorm(vmin=0.05, vmax=global_max)\n",
        "\n",
        "fig, ax = plt.subplots( )\n",
        "\n",
        "# Load first raster\n",
        "with xr.open_dataset(file_path[0], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "    data0 = ds[\"precipitation\"].sel(\n",
        "        lat=slice(lat_min, lat_max),\n",
        "        lon=slice(lon_min, lon_max)\n",
        "    ).isel(time=0).transpose(\"lat\", \"lon\")\n",
        "    lon = ds[\"lon\"].sel(lon=slice(lon_min, lon_max)).values\n",
        "    lat = ds[\"lat\"].sel(lat=slice(lat_min, lat_max)).values\n",
        "\n",
        "lon2d, lat2d = np.meshgrid(lon, lat)\n",
        "\n",
        "# Plot base precipitation frame\n",
        "mesh = ax.pcolormesh(\n",
        "    lon2d, lat2d, data0.values,\n",
        "    cmap=\"Blues\", shading=\"auto\", norm=norm, zorder=1\n",
        ")\n",
        "cbar = fig.colorbar(mesh, ax=ax, label=\"Precipitation (mm/hr)\")\n",
        "\n",
        "# Plot census tracts colored by population\n",
        "tracts.plot(\n",
        "    ax=ax,\n",
        "    column='B01003_001E',\n",
        "    cmap='Reds',\n",
        "    edgecolor='black',\n",
        "    linewidth=0.5,\n",
        "    alpha=0.6,\n",
        "    zorder=2,\n",
        "    legend=True,\n",
        "    legend_kwds={'label': \"Population (ACS B01003_001E)\"}\n",
        ")\n",
        "\n",
        "# Title and axes\n",
        "title_text = ax.set_title(\"Frame 1\")\n",
        "ax.set_xlabel(\"Longitude\")\n",
        "ax.set_ylabel(\"Latitude\")\n",
        "plt.tight_layout()\n",
        "\n",
        "# -----------------------------\n",
        "#  Define Animation\n",
        "# -----------------------------\n",
        "def update(frame_index):\n",
        "    file = file_path[frame_index]\n",
        "    with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "        data = ds[\"precipitation\"].sel(\n",
        "            lat=slice(lat_min, lat_max),\n",
        "            lon=slice(lon_min, lon_max)\n",
        "        ).isel(time=0).transpose(\"lat\", \"lon\")\n",
        "    \n",
        "    # Update raster data\n",
        "    data_vals = data.values\n",
        "    data_vals[data_vals <= 0] = np.nan  # Avoid log(0)\n",
        "    mesh.set_array(data_vals.ravel())\n",
        "\n",
        "    # Timestamp label\n",
        "    filename = os.path.basename(file)\n",
        "    date_match = re.search(r\"3IMERG\\.(\\d{8})\", filename)\n",
        "    time_match = re.search(r\"(\\d{4}).V07B\", filename)\n",
        "    if date_match and time_match:\n",
        "        date_str = date_match.group(1)\n",
        "        minutes = int(time_match.group(1))\n",
        "        dt = datetime.strptime(date_str, \"%Y%m%d\") + timedelta(minutes=minutes) - timedelta(hours=10)\n",
        "        label = dt.strftime(\"%Y-%m-%d %H:%M:%S HST\")\n",
        "    else:\n",
        "        label = \"Unknown timestamp\"\n",
        "\n",
        "    title_text.set_text(f\"Maui 2023 Population & Precipitation — {label}\")\n",
        "    return mesh, title_text\n",
        "\n",
        "#  \n",
        "#  Run and Save Animation\n",
        "#  \n",
        "ani = animation.FuncAnimation(\n",
        "    fig, update, frames=len(file_path),\n",
        "    interval=200, blit=True, repeat=False\n",
        ")\n",
        "\n",
        "ani.save(\"data/images/maui_precip_population.gif\", writer=\"pillow\", fps=3)"
      ],
      "id": "97f13683",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Maui Rain Population GIF](data/images/maui_precip_population.gif)\n",
        "\n",
        "\n",
        "## Using Drone Data for Damage Assessment\n",
        "\n",
        "Using **infrared (thermal) drone images for flooding damage assessment** helps identify water extent, saturation, and temperature contrasts that are not always visible in standard imagery. Thermal sensors can distinguish standing water from wet soil and detect moisture intrusion in buildings, supporting more accurate damage classification. Repeated infrared flights allow analysts to monitor receding floodwaters and lingering moisture that may indicate ongoing risk to structures or infrastructure. \n",
        "\n",
        "When combined with elevation, land cover, and parcel data, thermal imagery improves understanding of flood impacts across neighborhoods. As with all drone operations, data collection should follow airspace regulations and account for privacy and ethical considerations when surveying affected communities.\n"
      ],
      "id": "56c01c80"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# Folder containing infrared JPEG frames\n",
        "frames_dir = \"data/images/thermal\"\n",
        "image_files = sorted([\n",
        "    os.path.join(frames_dir, f)\n",
        "    for f in os.listdir(frames_dir)\n",
        "    if f.lower().endswith(\"_t.jpg\") or f.lower().endswith(\"_t.jpeg\")\n",
        "])"
      ],
      "id": "21148cc8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can plot the infrared images found from the drone to perform a damage assessment of roads in Maui and create a GIF animnation.\n"
      ],
      "id": "588c759c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# skip first 10, then take the next 25\n",
        "subset_files = image_files[10:35]\n",
        "\n",
        "\n",
        "# Set up the figure\n",
        "fig, ax = plt.subplots()\n",
        "ax.axis(\"off\")\n",
        "\n",
        "# Load the first frame\n",
        "img = Image.open(subset_files[0])\n",
        "im = ax.imshow(img, cmap=\"inferno\")\n",
        "\n",
        "def update(frame):\n",
        "    img = Image.open(subset_files[frame])\n",
        "    im.set_data(img)\n",
        "    return [im]\n",
        "\n",
        "# Create animation\n",
        "ani = animation.FuncAnimation(\n",
        "    fig,\n",
        "    update,\n",
        "    frames=len(subset_files),\n",
        "    interval=200,   # milliseconds between frames\n",
        "    blit=True\n",
        ")\n",
        "\n",
        "# Save as GIF\n",
        "ani.save(\"data/images/infrared_flood_animation.gif\",\n",
        "    writer=\"pillow\",\n",
        "    fps=4\n",
        ")\n",
        "\n",
        "plt.close(fig)"
      ],
      "id": "2b42e8ef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Maui Drone Infrared GIF](data/images/infrared_flood_animation.gif)\n",
        "\n",
        "\n",
        "## Discussion\n",
        "The analysis demonstrated that intense storms, such as the one that caused flooding in Maui in January 2024, can be studied effectively with the aid of open data and Python tools. Working with NASA’s IMERG rainfall dataset enabled us to observe the storms’ timing, intensity, and movement at 30-minute intervals. The animation helped highlight those transitions, making the storms peak visualize and link with population density data.\n",
        "\n",
        "When we compared NASA’s IMERG estimates with the Kahului Airport rain gauge data, we got similar rainfall timings, yet the exact rainfall totals differed. The main reason is that IMERG covers a large grid while a rain gauge measures a single point. Despite the difference, both sources demonstrated the same main rainfall surge.\n",
        "\n",
        "After adding 2023 census tract data, we were able to connect the rainfall patterns to communities. The overlap between the heaviest rainfall zones and the tracts with more seniors, children, and lower-income households showed clear differences in potential exposure. The demographic data combined with environmental data portrayed a more complete picture of risk. It showed not only where flooding was likely to occur, but also who might have the hardest time and will likely need help. \n",
        "\n",
        "The drone and MODIS imagery showed how surface water accumulated after the event. Even though the drone images were captured months after the event, they provided great context for infrastructure and drainage paths. Combined with satellite data, they confirmed which areas were repeatedly saturated and their likely causes.\n",
        "\n",
        "However, there are gaps in how infrastructure quality is measured. Open datasets on drainage systems and culvert capacity are limited. Due to the lack of datasets, we used spatial proxies in the analysis to find approximate flood pathways. Despite the constraints, we were able to identify several low-lying transportation pathways and coastal plains that may need improvement to reduce the damage if the event occurs again.\n",
        "\n",
        "Finally, the demographic of Maui added a social perspective to the technical analysis. Due to a large number of Native Hawaiian and Pacific Islander residents and a high cost of living, flood response efficiency depends not only on weather forecasts but also on communication and access. By linking rainfall intensity with population distribution, this analysis shows where outreach, support, and resources are needed most, reinforcing that flood risk is as much about people as it is about precipitation.\n",
        "\n",
        "## Conclusion\n",
        "You have just completed a hands-on exploration of how open datasets and Python workflows can be used to study flood impacts, using Maui flooding as an example. Through this analysis, we learned how to combine rainfall observations, population data, and spatial layers to understand both environmental and social exposure to storms.\n",
        "\n",
        "Throughout the process, we were able to:\n",
        "Access and visualize NASA’s IMERG rainfall data to observe storm timing, intensity, and movement.\n",
        "Compare satellite rainfall estimates with ground-based station data, validate patterns, and detect differences.\n",
        "Merge census tract boundaries with rainfall layers to outline which locations are most exposed to heavy rainfall.\n",
        "Use spatial analysis tools to identify low-lying areas, coastal zones, and transportal pathways with higher flood risk.\n",
        "Combine demographic and environmental data to figure out which populations, areas, and communities are likely to face greater challenges.\n",
        "\n",
        "By utilizing both environmental and demographic information, this project demonstrated how data analytics can support disaster preparedness and recovery planning. Understanding which areas are most likely to be in danger and who lives there helps communities and first responders create a smarter plan of action, allocate resources efficiently, and strengthen population and infrastructure for future storms.\n",
        "\n",
        "## Summary\n",
        "This workflow demonstrates how to:\n",
        "\n",
        "- Download and merge census tract boundaries and population data for Maui.\n",
        "- Process and map local rainfall station observations.\n",
        "- Overlay demographic and environmental data for actionable disaster analysis.\n",
        "\n",
        "You can expand this analysis by incorporating additional census variables, different time periods, or more advanced spatial statistics as needed for your project.   \n"
      ],
      "id": "73743bfc"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/CIESINIT/miniconda3/envs/school/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}