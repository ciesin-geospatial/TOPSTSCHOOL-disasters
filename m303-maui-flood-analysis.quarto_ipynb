{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Flood Watch Report â€“ Maui Heavy Rainfall Analysis\"\n",
        "author: \n",
        "  - \"Kytt MacManus, Raphael Sutiono, Francisco Sanchez, Mykola Dydych, Juan F. Martinez\"\n",
        "format: \n",
        "  html \n",
        "bibliography: m303-maui-flood-bibliography.bib\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "In this lesson, you will analyze the **Flash Flood Watch for Maui** issued in January 15, 2024 due to prolonged, heavy rainfall. You will simulate rainfall data to evaluate flood risks across different regions of the island. This type of hazard analysis helps develop early-warning systems and improve response strategies for climate-related emergencies.\n",
        "\n",
        "## Learning Objectives\n",
        "\n",
        "By the end of this lesson, you should be able to:\n",
        "\n",
        "- Understand the meteorological cause and risk factors of flash floods in Maui.\n",
        "- Access and work with NASA rainfall data using Python.\n",
        "- Compare NASA data and rain gauge data to see similarities.\n",
        "- Use U.S. Cenus data to determine how many households were affected by the event.\n",
        "\n",
        "## Introduction\n",
        "\n",
        "Flash floods are sudden, powerful events that can occur when intense rain overwhelms drainage systems. On the early hours of **January 16, 2024**, the National Weather Service issued a **Flood Watch for Maui**, warning residents of potentially hazardous rainfall due to a slow-moving weather system [@mauinow2024showers].\n",
        "\n",
        "Heavy rains, particularly over windward and wildfire-scarred slopes, threatened roads, homes, and infrastructure. This report explores the event using simulated rainfall data and visual  tools to assess possible flood impact zones.\n",
        "\n",
        "### NASA Global Precipitation Measurement (GPM)\n",
        "\n",
        "The **[Global Precipitation Measurement (GPM) IMERG Final Precipitation L3 Half Hourly 0.1 degree x 0.1 degree V07 (GPM_3IMERGHH)](https://disc.gsfc.nasa.gov/datasets/GPM_3IMERGHH_07/summary)** provides high-resolution multi-satellite precipitation estimates [@huffman2023imerg]. This dataset is produced by the Precipitation Processing System (PPS) at NASA's Goddard Space Flight Center (GSFC) and is distributed through the [Goddard Earth Sciences Data and Information Services Center (GES DISC)](https://disc.gsfc.nasa.gov/datasets/GPM_3IMERGHH_07/summary).\n",
        "\n",
        "\n",
        "\n",
        "### NASA Earthaccess\n",
        " \n",
        "NASA's `earthaccess` is a Python library designed to simplify the process of searching, accessing, and downloading Earth science data from NASA's repositories. It integrates seamlessly with [**NASA's Earthdata Login**](https://urs.earthdata.nasa.gov/) system, allowing users to authenticate and interact with various datasets programmatically.\n",
        "\n",
        "A NASA Earthdata Login profile is required to access Earthdata datasets for this lesson. \n",
        "\n",
        "\n",
        "### Open Street Map\n",
        "\n",
        "[OpenStreetMap (OSM)](https://www.openstreetmap.org/) is a collaborative project that creates a free, editable map of the world, built entirely by a community of mappers. In Python, the osmnx library provides a powerful interface for querying and analyzing OSM data, including administrative boundaries, road networks, and building footprints.\n",
        "\n",
        "In this lesson, we use `osmnx` to retrieve the geographic boundary of Hawaii from OSM and extract its bounding box to spatially filter satellite precipitation data.\n",
        "\n",
        "\n",
        "\n",
        "## Data Analysis\n",
        "\n",
        "::: {.callout-tip style=\"color: #5a7a2b;\"}\n",
        "#### Data Science Review\n",
        "\n",
        "Before beginning, please note that this lesson uses the Python programming language and the following Python packages:\n",
        "\n",
        "\n",
        "-   [`os`](https://docs.python.org/3/library/os.html): Provides a portable way to interact with the operating system, including file system operations and environment variables.\n",
        "\n",
        "-   [`re`](https://docs.python.org/3/library/re.html): Enables powerful string pattern matching and text processing using regular expressions.\n",
        "\n",
        "-   [`datetime`](https://docs.python.org/3/library/datetime.html): Used to manipulate dates and times, including timedelta arithmetic for time-based analysis.\n",
        "\n",
        "-   [`numpy`](https://numpy.org/): Foundational package for scientific computing in Python, supporting array operations and numerical computation.\n",
        "\n",
        "-   [`pandas`](https://pandas.pydata.org/): Offers data structures and functions for handling, analyzing, and visualizing structured data.\n",
        "\n",
        "-   [`xarray`](https://docs.xarray.dev/): Enables working with labeled multi-dimensional arrays, ideal for processing NetCDF and other gridded scientific data.\n",
        "\n",
        "-   [`matplotlib.pyplot`](https://matplotlib.org/stable/api/pyplot_api.html): Core plotting library for generating static, interactive, and animated visualizations in Python.\n",
        "\n",
        "-   [`matplotlib.animation`](https://matplotlib.org/stable/api/animation_api.html): Provides tools for creating animated plots and time series visualizations.\n",
        "\n",
        "-   [`osmnx`](https://osmnx.readthedocs.io/): Enables downloading, visualizing, and analyzing street networks and other OpenStreetMap data.\n",
        "\n",
        "-   [`rasterio.transform`](https://rasterio.readthedocs.io/en/latest/topics/transforms.html): Supports creation and manipulation of geospatial raster transforms for coordinate referencing.\n",
        "\n",
        "-   [`rasterstats`](https://pythonhosted.org/rasterstats/): Computes summary statistics of raster datasets over vector geometries for spatial analysis.\n",
        "\n",
        "-   [`earthaccess`](https://earthaccess.readthedocs.io/): Simplifies NASA Earthdata access by managing authentication and dataset queries in a user-friendly way.\n",
        "\n",
        "\n",
        "\n",
        ":::\n"
      ],
      "id": "ad80d662"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import os\n",
        "import re\n",
        "from datetime import datetime, timedelta\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import xarray as xr\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import matplotlib.animation as animation\n",
        "\n",
        "import osmnx as ox\n",
        "from rasterio.transform import from_origin\n",
        "from rasterstats import zonal_stats\n",
        "\n",
        "import earthaccess\n"
      ],
      "id": "eb33e633",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The earthaccess library simplifies the process of accessing NASA Earthdata by handling authentication and data discovery. Before you can search or download data using earthaccess, you need to authenticate using your Earthdata Login credentials. The `earthaccess.login()` function is the starting point for this process.\n"
      ],
      "id": "a9789e4b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        " \n",
        "# Authenticate with Earthdata using your Earthdata Login credentials\n",
        "# This will prompt for username/password or use existing credentials  \n",
        " earthaccess.login()"
      ],
      "id": "bd745601",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To retrieve NASA precipitation data for Hawaii using earthaccess, we begin by querying geographic boundary data from OpenStreetMap using osmnx, then extract the bounding box for the region. This bounding box is used to search for GPM IMERG half-hourly precipitation data for a specific date range. \n"
      ],
      "id": "0d31f562"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Query Hawaii boundary from OSM  \n",
        "hawaii = ox.geocode_to_gdf(\"Hawaii, USA\")\n",
        "\n",
        "\n",
        "# Extract bounding box as (lon_min, lat_min, lon_max, lat_max)\n",
        "bbox = hawaii.total_bounds  # [minx, miny, maxx, maxy]\n",
        "bounding_box = (bbox[0], bbox[1], bbox[2], bbox[3])"
      ],
      "id": "a5529cf4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Search for GPM IMERG Half-Hourly Precipitation Data:\n"
      ],
      "id": "fa7be7b6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Search for GPM IMERG Half-Hourly Level 3 data using earthaccess\n",
        "results = earthaccess.search_data(\n",
        "    short_name=\"GPM_3IMERGHH\",     # Dataset short name\n",
        "    version=\"07\",                  # Dataset version\n",
        "    temporal=(\"2024-01-16\", \"2024-01-17\"),  # Example date range\n",
        "    bounding_box=bounding_box      # Geographic bounding box for Hawaii\n",
        ")\n",
        "\n",
        "# Extract data download links from search results\n",
        "all_urls = [granule.data_links()[0] for granule in results]\n",
        "\n",
        "# Print number of URLs found\n",
        "print(len(all_urls), \"URLs found.\")\n"
      ],
      "id": "9098d1a9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, this code will download and create a list of the file paths of the downloaded data from `earthaccess`:"
      ],
      "id": "7cdac9bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "#| \n",
        "file_path = earthaccess.download(all_urls)"
      ],
      "id": "c350a5a9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": " "
      },
      "source": [
        "#|include: false\n",
        "\n",
        "\n",
        "\n",
        "folder= r\"F:\\TOPSSCHOOL\\git\\TOPSTSCHOOL-disasters\\data\\2025-07-07-47e9ab\"\n",
        "\n",
        "file_path= [os.path.join(folder, f) for f in os.listdir(folder) if \\\n",
        " os.path.isfile(os.path.join(folder, f))]\n",
        "print(file_path)\n"
      ],
      "id": "1b2da44f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Visualizing Precipitation Data\n",
        "\n",
        "Once weâ€™ve downloaded the GPM IMERG precipitation data, we can use `xarray` to open the **NetCDF** file and subset it to the region of interest (in this case, Hawaii). This subset is then visualized using `matplotlib` and xarrayâ€™s built-in plotting utilities to generate a precipitation map for the first available half-hourly time step.\n"
      ],
      "id": "7ea71fc4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Display the number of observations (files) found\n",
        "print(len(file_path), \"observations found.\")\n",
        "\n",
        "# Open the selected GPM IMERG dataset (e.g., 16th file in list)\n",
        "with xr.open_dataset(file_path[15], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "\n",
        "    # Subset the precipitation variable to the Hawaii bounding box\n",
        "    precip_subset = ds[\"precipitation\"].sel(\n",
        "        lat=slice(bounding_box[1], bounding_box[3]),\n",
        "        lon=slice(bounding_box[0], bounding_box[2])\n",
        "    )\n",
        "\n",
        "    # Select the first time step and reorient data for plotting\n",
        "    data = precip_subset.isel(time=0)\n",
        "    data = data.transpose(\"lat\", \"lon\")\n",
        "\n",
        "# Create a figure and axis\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Plot the precipitation data\n",
        "data.plot(ax=ax, cmap=\"Blues\", cbar_kwargs={\"label\": \"Precipitation (mm/hr)\"})\n",
        "\n",
        "# Overlay the Hawaii boundary geometry from OSM\n",
        "hawaii.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5)\n",
        "\n",
        "# Add plot labels and formatting\n",
        "plt.title(\"GPM IMERG Precipitation over Hawaii with OSM Boundary\")\n",
        "plt.xlabel(\"Longitude\")\n",
        "plt.ylabel(\"Latitude\")\n",
        "plt.tight_layout()\n",
        "plt.show()\n"
      ],
      "id": "acca3a9a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Animation: Visualizing Half-Hourly Rainfall Over Time\n",
        "\n",
        "To understand how precipitation evolves over time, we can animate the sequence of GPM IMERG half-hourly rainfall images. This animation cycles through each file, extracts the timestamp, overlays the precipitation data on the Hawaii boundary, and renders a smooth temporal visualization using `matplotlib.animation`. This is especially helpful for spotting storm patterns and tracking rainfall intensity across the region.\n"
      ],
      "id": "8adea1d7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# Initialize the figure\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Load first dataset \n",
        "# Open the first NetCDF file using xarray\n",
        "with xr.open_dataset(file_path[0], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "    \n",
        "    # Subset the precipitation variable by latitude and longitude bounds\n",
        "    data0 = ds[\"precipitation\"].sel(\n",
        "        lat=slice(bounding_box[1], bounding_box[3]),    # min_lat to max_lat\n",
        "        lon=slice(bounding_box[0], bounding_box[2])     # min_lon to max_lon\n",
        "    ).isel(time=0).transpose(\"lat\", \"lon\")              # Select first time step and orient for plotting\n",
        "\n",
        "    # Extract longitude and latitude values as 1D arrays\n",
        "    lon = data0.lon.values\n",
        "    lat = data0.lat.values\n",
        "\n",
        "    # Create 2D meshgrid from lat/lon arrays for plotting\n",
        "    lon2d, lat2d = np.meshgrid(lon, lat)\n",
        "\n",
        "    # Plot the initial frame with pcolormesh and add color shading\n",
        "    mesh = ax.pcolormesh(lon2d, lat2d, data0.values, cmap=\"Blues\", shading=\"auto\")\n",
        "\n",
        "    # Add a colorbar to indicate precipitation scale\n",
        "    cbar = fig.colorbar(mesh, ax=ax, label=\"Precipitation (mm/hr)\")\n",
        "\n",
        "# Overlay the Hawaii boundary outline from OSM data\n",
        "hawaii.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5, zorder=2)\n",
        "\n",
        "# Add static plot title with frame info\n",
        "title_text = ax.set_title(f\"GPM IMERG Precipitation over Hawaii - Frame 1/{len(file_path)}\")\n",
        "\n",
        "# Set axis labels\n",
        "ax.set_xlabel(\"Longitude\")\n",
        "ax.set_ylabel(\"Latitude\")\n",
        "\n",
        "# Auto-adjust layout to prevent overlap of labels and plot\n",
        "plt.tight_layout()\n",
        "\n",
        "# --- Define update function for animation ---\n",
        "\n",
        "def update(frame_index):\n",
        "    # Get the file for the current frame\n",
        "    file = file_path[frame_index]\n",
        "\n",
        "    # Open and subset the current file's data\n",
        "    with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "        data = ds[\"precipitation\"].sel(\n",
        "            lat=slice(bounding_box[1], bounding_box[3]),  # Subset latitude\n",
        "            lon=slice(bounding_box[0], bounding_box[2])   # Subset longitude\n",
        "        ).isel(time=0).transpose(\"lat\", \"lon\")            # Select first time slice and orient for plotting\n",
        "\n",
        "    # Extract filename from full path\n",
        "    filename = os.path.basename(file)\n",
        "\n",
        "    # Use regex to extract date (YYYYMMDD) from filename\n",
        "    match = re.search(r\"3IMERG\\.(\\d{8})\", filename)\n",
        "    date_str = match.group(1)\n",
        "\n",
        "    # Use regex to extract time (HHMM) from filename\n",
        "    match = re.search(r\"(\\d{4}).V07B\", filename)\n",
        "    time_str = match.group(1)\n",
        "    time_str = int(time_str)  # Convert to integer (minutes)\n",
        "\n",
        "    # Convert extracted date/time to a datetime object in Hawaii Standard Time (HST)\n",
        "    try: \n",
        "        datetime_obj = datetime.strptime(date_str, \"%Y%m%d\")           # Parse date string\n",
        "        datetime_obj = datetime_obj + timedelta(minutes=time_str)      # Add minutes offset\n",
        "        datetime_obj = datetime_obj - timedelta(hours=10)              # Convert UTC to HST\n",
        "        timestamp_str = datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S HST\") # Format timestamp string\n",
        "\n",
        "    except ValueError:\n",
        "        # Handle parsing errors\n",
        "        timestamp_str = f\"Invalid time in filename: {time_str}\"\n",
        "\n",
        "    # Update the plot data with the current frame\n",
        "    mesh.set_array(data.values.ravel())\n",
        "\n",
        "    # Update the title with the new timestamp\n",
        "    title_text.set_text(f\"GPM IMERG Precipitation over Hawaii â€” {timestamp_str}\")\n",
        "\n",
        "    # Return updated elements for blitting\n",
        "    return mesh, title_text\n",
        "\n",
        "# --- Create the animation ---\n",
        "\n",
        "print(\"Creating animation...\")\n",
        "\n",
        "ani = animation.FuncAnimation(\n",
        "    fig,                # Target figure object\n",
        "    update,             # Function to call for each frame\n",
        "    frames=len(file_path), # Total number of frames (data files)\n",
        "    interval=200,       # Delay between frames in milliseconds\n",
        "    blit=True,          # Only redraw changed elements for efficiency\n",
        "    repeat=False        # Stop at the last frame\n",
        ")\n",
        "\n",
        "# --- Save the animation as a GIF ---\n",
        "\n",
        "ani.save(\"data/images/hawaii_precip.gif\", writer=\"pillow\", fps=3)  # Save at 3 frames per second\n"
      ],
      "id": "de944ea3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Hawaii GIF](data/images/hawaii_precip.gif)\n",
        "\n",
        " \n",
        "#### Focusing on Maui\n",
        "\n",
        "To focus analysis on our location of analysis, we use `osmnx` to retrieve the geographic boundary for Maui County, Hawaii from **OpenStreetMap**. We then extract its bounding box and apply a small buffer (0.1 degrees) to ensure that nearby data just outside the strict boundary is included. This padded extent will be used to spatially filter satellite precipitation data or other geospatial layers relevant to the region.\n"
      ],
      "id": "591509db"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Get the geometry for Maui County, Hawaii from OpenStreetMap\n",
        "maui = ox.geocode_to_gdf(\"Maui County, Hawaii, USA\").to_crs(\"EPSG:4326\")\n",
        "\n",
        "# Extract the bounding box of Maui County as (minx, miny, maxx, maxy)\n",
        "bounding_box = maui.total_bounds\n",
        "\n",
        "# Define a small padding buffer (in degrees) around the bounding box\n",
        "pad = 0.1  # ~0.1 degrees â‰ˆ 5â€“6 km buffer\n",
        "\n",
        "# Compute padded latitude and longitude boundaries\n",
        "lat_min = bounding_box[1] - pad  # Southern boundary\n",
        "lat_max = bounding_box[3] + pad  # Northern boundary\n",
        "lon_min = bounding_box[0] - pad  # Western boundary\n",
        "lon_max = bounding_box[2] + pad  # Eastern boundary\n"
      ],
      "id": "24e9a505",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "After defining the padded bounding box for Maui, we can visualize GPM IMERG half-hourly precipitation data for that area. This plot overlays satellite-derived rainfall intensity on the islandâ€™s geographic outline using `xarray` and `matplotlib`, providing spatial context for localized precipitation events.\n"
      ],
      "id": "42211078"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Open the 16th GPM IMERG data file and extract the \"Grid\" group\n",
        "with xr.open_dataset(file_path[15], engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "    \n",
        "    # Subset the precipitation variable using the padded Maui bounding box\n",
        "    precip_subset = ds[\"precipitation\"].sel(\n",
        "        lat=slice(lat_min, lat_max),   # Latitude range from bounding box\n",
        "        lon=slice(lon_min, lon_max)    # Longitude range from bounding box\n",
        "    )\n",
        "\n",
        "    # Select the first time step in the file\n",
        "    data = precip_subset.isel(time=0)\n",
        "\n",
        "    # Rearrange dimensions for plotting: lat first, then lon\n",
        "    data = data.transpose(\"lat\", \"lon\")\n",
        "\n",
        "# Initialize figure and axis for the plot\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Plot the precipitation data on the map\n",
        "data.plot(ax=ax, cmap=\"Blues\", cbar_kwargs={\"label\": \"Precipitation (mm/hr)\"})\n",
        "\n",
        "# Overlay the Maui County boundary using OSM data\n",
        "maui.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5)\n",
        "\n",
        "# Add plot title and axis labels\n",
        "plt.title(\"GPM IMERG Precipitation over Hawaii with OSM Boundary\")\n",
        "plt.xlabel(\"Longitude\")\n",
        "plt.ylabel(\"Latitude\")\n",
        "\n",
        "# Adjust layout to prevent overlap\n",
        "plt.tight_layout()\n",
        "\n",
        "# Display the plot\n",
        "plt.show()\n"
      ],
      "id": "3348bf07",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To visualize how rainfall evolves across Maui County, this animation cycles through a sequence of GPM IMERG half-hourly datasets. For each frame, it subsets the data to the Maui region, overlays the county boundary, and updates the timestamp extracted from the filename. The animation is then saved as a `.gif` for easy sharing and visual analysis.\n"
      ],
      "id": "feabd4fd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# Initialize the figure and axis for the animation\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Inform the user that we're starting the first frame setup\n",
        "print(\"Initializing plot with first data file...\")\n",
        "\n",
        "# Extract longitude and latitude from the preloaded 'data' array\n",
        "lon = data.lon.values                       # 1D longitude array\n",
        "lat = data.lat.values                       # 1D latitude array\n",
        "\n",
        "# Create 2D coordinate grids from the lat/lon arrays\n",
        "lon2d, lat2d = np.meshgrid(lon, lat)\n",
        "\n",
        "# Create the first pcolormesh using initial data values\n",
        "mesh = ax.pcolormesh(\n",
        "    lon2d, lat2d, data.values,              # Coordinates and initial data\n",
        "    cmap=\"Blues\", shading=\"auto\"           # Colormap and smoothing style\n",
        ")\n",
        "\n",
        "# Add a colorbar to show precipitation intensity\n",
        "cbar = fig.colorbar(mesh, ax=ax, label=\"Precipitation (mm/hr)\")\n",
        "\n",
        "# Overlay Maui County's boundary for spatial context\n",
        "maui.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=1.5, zorder=2)\n",
        "\n",
        "# Set static elements for the plot: title and axis labels\n",
        "title_text = ax.set_title(f\"GPM IMERG Precipitation over Hawaii - Frame 1/{len(file_path)}\")\n",
        "ax.set_xlabel(\"Longitude\")\n",
        "ax.set_ylabel(\"Latitude\")\n",
        "plt.tight_layout()  # Optimize spacing to prevent overlap\n",
        "\n",
        "# --- Define the animation update function ---\n",
        "\n",
        "def update(frame_index):\n",
        "    # Get the file corresponding to the current animation frame\n",
        "    file = file_path[frame_index]\n",
        "\n",
        "    # Open and subset the dataset for Maui bounding box\n",
        "    with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "        data = ds[\"precipitation\"].sel(\n",
        "            lat=slice(lat_min, lat_max),   # Subset latitude\n",
        "            lon=slice(lon_min, lon_max)    # Subset longitude\n",
        "        ).isel(time=0).transpose(\"lat\", \"lon\")  # Select first timestep and rearrange dimensions\n",
        "\n",
        "    # Extract the base filename (no directory)\n",
        "    filename = os.path.basename(file)\n",
        "\n",
        "    # Extract date string (YYYYMMDD) from filename using regex\n",
        "    match = re.search(r\"3IMERG\\.(\\d{8})\", filename)\n",
        "    date_str = match.group(1)\n",
        "\n",
        "    # Extract time offset (HHMM in minutes) from filename\n",
        "    match = re.search(r\"(\\d{4}).V07B\", filename)\n",
        "    time_str = match.group(1)\n",
        "    time_str = int(time_str)  # Convert to integer\n",
        "\n",
        "    # Attempt to convert extracted date and time to formatted timestamp\n",
        "    try: \n",
        "        datetime_obj = datetime.strptime(date_str, \"%Y%m%d\")       # Parse date\n",
        "        datetime_obj += timedelta(minutes=time_str)                # Add time offset\n",
        "        datetime_obj -= timedelta(hours=10)                        # Convert from UTC to HST\n",
        "        timestamp_str = datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S HST\")  # Format timestamp\n",
        "    except ValueError:\n",
        "        # Handle invalid or missing time values\n",
        "        timestamp_str = f\"Invalid time in filename: {time_str}\"\n",
        "\n",
        "    # Update plot with new data values and title\n",
        "    mesh.set_array(data.values.ravel())  # Flatten the data into 1D for pcolormesh\n",
        "    title_text.set_text(f\"GPM IMERG Precipitation over Hawaii â€” {timestamp_str}\")\n",
        "\n",
        "    return mesh, title_text  # Return updated elements for blitting\n",
        "\n",
        "# --- Generate the animation ---\n",
        "\n",
        "print(\"Creating animation...\")\n",
        "\n",
        "ani = animation.FuncAnimation(\n",
        "    fig,            # The figure object to update\n",
        "    update,         # The update function called per frame\n",
        "    frames=len(file_path),  # Number of frames = number of files\n",
        "    interval=200,   # Delay between frames (ms)\n",
        "    blit=True,      # Use blitting for efficient updates\n",
        "    repeat=False    # Run only once\n",
        ")\n",
        "\n",
        "# --- Save the animation as a GIF ---\n",
        "\n",
        "ani.save(\"data/images/maui_precip.gif\", writer=\"pillow\", fps=3)  # Save to file at 3 frames per second"
      ],
      "id": "5d59209a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Maui GIF](data/images/maui_precip.gif)\n",
        "\n",
        "### Extracting Time Series of Mean Precipitation Over Maui\n",
        "\n",
        "\n",
        "We can use the GPM IMERG half-hourly precipitation files to calculates the mean rainfall over Maui County for each timestep. The data is spatially subset to the OSM Maui bounding box, rasterized using a *geographic transform*, and then aggregated over the island polygon using the function `zonal_stats`. Results are compiled into a *DataFrame* for further analysis or plotting.\n"
      ],
      "id": "d21f2b61"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Prepare an empty list to store the results for each file\n",
        "results = []\n",
        "\n",
        "# Loop through each file in the downloaded GPM IMERG dataset\n",
        "for file in file_path:\n",
        "    try:\n",
        "        # --- Open and subset precipitation data ---\n",
        "        with xr.open_dataset(file, engine=\"h5netcdf\", group=\"Grid\") as ds:\n",
        "            # Select and subset precipitation for Maui bounding box\n",
        "            data = ds[\"precipitation\"].sel(\n",
        "                lat=slice(lat_min, lat_max),     # Latitude bounds\n",
        "                lon=slice(lon_min, lon_max)      # Longitude bounds\n",
        "            ).isel(time=0).transpose(\"lat\", \"lon\")  # First timestep and axis order for raster analysis\n",
        "\n",
        "        # --- Build affine transform for georeferencing raster ---\n",
        "        lats = data[\"lat\"].values              # Latitude array\n",
        "        lons = data[\"lon\"].values              # Longitude array\n",
        "        res_x = lons[1] - lons[0]              # Pixel width\n",
        "        res_y = lats[1] - lats[0]              # Pixel height (note: no flip needed if ordered from top to bottom)\n",
        "        transform = from_origin(\n",
        "            west=lons.min(),                   # Western edge\n",
        "            north=lats.max(),                  # Northern edge\n",
        "            xsize=res_x,                       # Horizontal resolution\n",
        "            ysize=res_y                        # Vertical resolution\n",
        "        )\n",
        "\n",
        "        # --- Extract raw array of precipitation values ---\n",
        "        arr = data.values                      # 2D array (lat Ã— lon)\n",
        "\n",
        "        # --- Parse datetime from filename ---\n",
        "        filename = os.path.basename(file)      # Extract base filename\n",
        "        match_date = re.search(r\"3IMERG\\.(\\d{8})\", filename)   # Extract date string (YYYYMMDD)\n",
        "        match_min = re.search(r\"\\.(\\d{4,5})\\.V\", filename)     # Extract time in minutes\n",
        "\n",
        "        if match_date and match_min:\n",
        "            date_str = match_date.group(1)\n",
        "            mins_str = match_min.group(1)\n",
        "            dt = datetime.strptime(date_str, \"%Y%m%d\") + timedelta(minutes=int(mins_str))  # Combine date and time\n",
        "            dt = dt - timedelta(hours=10)      # Convert from UTC to Hawaii Standard Time\n",
        "        else:\n",
        "            dt = None                          # Fallback if parsing fails\n",
        "\n",
        "        # --- Compute zonal mean over the Maui polygon ---\n",
        "        stats = zonal_stats(\n",
        "            maui,                              # Polygon geometry\n",
        "            arr,                               # Raster array\n",
        "            affine=transform,                  # Spatial transform\n",
        "            stats=\"mean\",                      # Compute mean value\n",
        "            nodata=np.nan                      # Handle missing values\n",
        "        )[0]\n",
        "\n",
        "        # Extract mean precipitation value from the stats result\n",
        "        mean_precip = stats[\"mean\"]\n",
        "\n",
        "        # Append timestamp and mean to results list\n",
        "        results.append({\n",
        "            \"datetime\": dt,\n",
        "            \"mean_precip\": mean_precip\n",
        "        })\n",
        "\n",
        "    except Exception as e:\n",
        "        # Catch and report any errors (e.g., malformed file or data)\n",
        "        print(f\"Skipping file {file} due to error: {e}\")\n",
        "\n",
        "# --- Convert results list to a clean DataFrame ---\n",
        "results_df = pd.DataFrame(results)  # Each row: [datetime, mean_precip]"
      ],
      "id": "2029dc08",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that weâ€™ve extracted mean precipitation values for each GPM IMERG file, we can visualize how rainfall changes over time across Maui County. This line plot presents a temporal snapshot of precipitation intensity, helping to identify storm events, rainfall variability, and dry periods.\n"
      ],
      "id": "44421456"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create the time series line plot\n",
        "plt.figure(figsize=(12, 6))  # Set figure size for clarity and legibility\n",
        "\n",
        "# Plot datetime vs. mean precipitation with markers and connecting lines\n",
        "plt.plot(results_df['datetime'], results_df['mean_precip'], marker='o', linestyle='-')\n",
        "\n",
        "# Add a title and axis labels to describe the plot\n",
        "plt.title('Mean Precipitation Over Maui County Time Series')     # Plot title\n",
        "plt.xlabel('Date and Time (HST)')                                 # X-axis label\n",
        "plt.ylabel('Mean Precipitation')                                  # Y-axis label (units assumed mm/hr)\n",
        "\n",
        "# Automatically format x-axis to prevent overlapping date labels\n",
        "plt.gcf().autofmt_xdate()  # Rotate and align date labels on the x-axis\n",
        "\n",
        "# Add a dashed grid to the background for easier reading\n",
        "plt.grid(True, linestyle='--', alpha=0.7)  # Enable grid with light dashed lines\n",
        "\n",
        "# Adjust spacing to prevent overlapping elements\n",
        "plt.tight_layout()\n",
        "\n",
        "# Display the plot in the output cell\n",
        "plt.show()"
      ],
      "id": "6a0e33c0",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}